# 是否需要一个 Set-User-ID 或 Set-Group-ID 程序

有关编写 `Set-User-ID` 和 `Set-Group-ID` 程序的最佳建议中的一条就是尽量避免编写这种程序。在执行一个任务时如果存在无需赋给程序权限的方法，那么一般来讲应该采用这种方法，因为这样就能消除发生安全性问题的可能。

有时候可以将需要权限才能完成的功能拆分到一个只执行单个任务的程序中，然后在需要的时候在子进程中执行这个程序。

即使有时候需要 `Set-User-ID` 或 `Set-Group-ID`  权限，对于一个 `Set-User-ID` 程序来讲也并不总是需要赋给进程 `root` 身份，如果赋给进程其他一些身份已经足够，那么就应该采用这种方法。

# 以最小权限操作

程序应该总是使用完成当前所执行的任务所需的最小权限来操作，saved 的 `Set-User-ID` 工具就是为此设计的。

## 按需拥有权限

在 `Set-User-ID` 程序中可以临时删除并在之后重新获取权限：

```
uid_t orig_euid;

orig_euid = geteuid();
if(seteuid(geteuid()) == -1)  //@ 使调用进程有效用户 ID 变成真实 ID
	errExit("seteuid()");

//@ do unprivileged work

if(seteuid(orig_euid) == -1) //@ 将有效用户 ID 还原成 save set-user-id 程序中保存的值
	errExit("seteuid()");
```

最安全都额做法是在程序启动的时候立即删除权限，然后在后面需要的时候临时重新获得这些权限，如果在某个特定时刻之后永远不会再次请求权限时，那么程序应该删除这些权限。

### 在无需使用权限时永久地删除权限

如果 `Set-User-ID` 或者 `Set-Group-ID` 程序完成了所有需要权限的任务，那么它应该永久地删除这些权限以消除任何由于程序中包含 bug 或其他意料之外的行为而可能引起的安全风险。永久删除权限是通过将所有进程用户(组) ID 重置为真实(组) ID 来完成的。

对于一个当前有效用户 ID 为 0 的 `Set-User-ID-root` 程序来讲，可以使用下面的代码来重置所有的用户 ID：

```
if(setuid(geteuid()) == -1)
	errExit("setuid()");
```

当调用进程的有效用户 ID 非 0，上面的代码不会重置 `saved set-user-ID`，此时 `seteuid()` 只会修改有效用户 ID

在 `set-group-ID` 程序中永久地删除一个特权组 ID 同样必须要使用 `setregid()` 或 `setresgid()` 系统调用，因为当程序的有效用户 ID 不为 0 时，`setgid()` 只会修改调用进程的有效组 ID。

### 修改进程身份信息的注意事项

- 一些修改进程身份信息的系统调用在不同的系统上的语义是不相同的，此外，此类系统调用中的一些在调用者是特权进程时与非特权进程时表现出来的语义也是不同的
- 在 Linux 上，即使调用者的有效用户 ID 为 0，修改身份信息的系统调用在程序显式地操作其能力时也可能表现出意料之外的行为

由于以上两个可能性，强烈建议不仅需要检查一个修改身份信息的系统调用的成功与否，还需要验证修改行为是否如期的那样。

一些身份信息的变更只能由有效用户 ID 为 0 的进程来完成，因此在修改多个 ID 时：辅助组 ID，组ID，和用户 ID；先删除特权 ID，最后再删除特权有效用户 ID。相应地，在提升特权 ID 时应该先提升特权有效用户 ID。

# 小心执行程序









