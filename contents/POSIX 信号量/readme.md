# 概述

信号量是用来同步进程和线程对共享资源的访问的。SUSv3规定了两种类型的 POSIX 信号量：

- 命名信号量：这种信号量拥有一个名字。通过使用相同的名字调用 `sem_open()`，不相关的进程能够访问同一个信号量
- 未命名信号量：这种信号量没有名字，相反，它位于内存中一个预先商定的位置处。当在进程间共享时，信号量必须位于同一个共享内存区域中。当在线程间共享时，信号量可以位于被这些线程共享的一块内存区域中(比如堆上或者一个全局变量中)

POSIX 信号量的运作方式与 System V 信号量类似，即 POSIX 信号量是一个整数，其值是不能小于 0 的。如果一个进程试图将一个信号量的值减少到小于0，那么取决于所使用的函数，调用会阻塞或返回一个表明当前无法执行相应操作的产物。

# 命名信号量

要使用命名信号量必须要使用下列函数：

- `sem_open()` 函数打开或者创建一个信号量并返回一个句柄以供后继调用使用，如果这个调用会创建信号量的话还会对所创建的信号量进行初始化
- `sem_post(sem)` 和 `sem_wait(sem)` 函数分别递增和递减一个信号量值
- `sem_getvalue()` 函数获取一个信号量的当前值
- `sem_close()` 函数删除调用进程与它之前打开的一个信号量之间的关联关系
- `sem_unlink()` 函数删除一个信号量名字并将其标记为在所有进程关闭该信号量时删除该信号量

SUSv3 并没有规定如何实现命名信号量。一些 UNIX 实现将它们创建成位于标准文件系统上一个特殊位置处的文件。在 Linux 上，命名信号量被创建成小型 POSIX 共享内存对象，其名字的形式为 `sem.name`，这些对象将被放在一个挂载在 `/dev/shm` 目录之下的专用 `tmpfs` 文件系统中。这个文件系统具备内核持久性，它包含的信号量对象将会持久，即使当前没有进程打开它们。除非系统被关闭，否则这些对象将一直存在。

## 打开一个命名信号量

`sem_open()` 函数创建和打开一个新的命名信号量或打开一个既有信号量。

```
#include <fcntl.h>        
#include <sys/stat.h> 
#include <semaphore.h>

sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);
```

- `name` 标识出了信号量
- `oflag ` 确定了是打开一个既有信号量还是创建并打开一个新信号量：

  - 如果  `oflag`  是 0，那么将访问一个既有信号量
  -  如果在 `oflag` 中指定了 `O_CREAT`，那么如果信号量尚不存在，则创建该信号量。
  - 如果 `O_CREAT` 和 `O_EXCL` 都在 `oflag` 中指定，那么如果具有给定名称的信号量已经存在，则返回错误，调用失败
- 如果 `sem_open()` 被用来打开一个既有信号量，那么调用就只需要两个参数。但如果在 `flags`  中指定了 `O_CREAT`，那么就还需要另外两个参数：`mode` 和 `value`
- `mode` 参数是一个位掩码，它指定了施加于新信号量之上的权限，并且与 `open()` 一样，`mode` 参数中的值会根据进程的 `umask` 来取掩码， 应该向将访问信号量的每一类用户授予读和写权限
- `value` 参数是一个无符号整数，它指定了新信号量的初始值。信号量的创建和初始化操作是原子的，这样就避免了 System V 信号量初始化时所需完成的复杂工作了

不管是创建一个新信号量还是打开一个既有信号量，`sem_open()` 都会返回一个指向一个 `sem_t` 值的指针，而在后续的调用中则可以通过这个指针来操作这个信号量。`sem_open()` 在发生错误时会返回 `SEM_FAILED` 值。

USv3 声称当在 `sem_open()` 的返回值指向的 `sem_t` 变量的副本上执行操作（`sem_post()`、`sem_wait()` 等）时结果是未定义的。换句话说，像下面这种使用 `sem2` 的做法是不允许的：

```
sem_t *sp, sem2;
sp = sem_open(...);
sem2 = *sp;
sem_wait(&sem2);
```

通过 `fork()` 创建的子进程会继承其父进程打开的所有命名信号量的引用。在 `fork()` 之后，父进程和子进程就能够使用这些信号量来同步它们的动作了。

## 关闭一个信号量

当一个进程打开一个命名信号量时，系统会记录进程与信号量之间的关联关系。`sem_close()` 函数会终止这种关联关系(关闭信号量)，释放系统为该进程关联到该信号量之上的所有资源，并递减引用该信号量的进程数。

```
#include <semaphore.h>

int sem_close(sem_t *sem);
```

打开的命名信号量在进程终止时或者进程执行了一个 `exec()` 时会自动被关闭。

关闭一个信号量并不会删除这个信号量，而要删除这个信号量则要使用 `sem_unlink()`。

## 删除一个命名信号量

`sem_unlink()` 函数删除通过 `name` 标识的信号量并将信号量标记成一旦所有进程都使用完这个信号量时就销毁该信号量。

```
#include <semaphore.h>

int sem_unlink(const char *name);
```

一旦所有其他打开信号量的进程关闭它，信号量就会被销毁。 

# 信号量操作

## 等待一个信号量

```
include <semaphore.h>

int sem_wait(sem_t *sem);
```

- `sem_wait()` 会将 `sem` 引用的信号量值减小1：
  - 如果信号量的当前值大于 0，那么 `sem_wait()` 会立即返回
  - 如果信号量的当前值等于 0，那么 `sem_wait()` 会阻塞直到信号量的值大于 0 为止
- 如果一个阻塞的 `sem_wait()` 调用被一个信号处理器中断了，那么它就会失败并返回 `EINTR` 错误，不管在使用 `sigaction()` 建立这个信号处理器时是否采用了 `SA_RESTART` 标记。（在其他一些 UNIX 实现上，`SA_RESTART` 会导致 `sem_wait()` 自动重启。）

```
#include <semaphore.h>

int sem_trywait(sem_t *sem);
```

- `sem_trywait()` 函数是 `sem_wait()` 的一个非阻塞版本。如果递减操作无法立即被执行，那么 `sem_trywait()` 就会失败并返回 `EAGAIN` 错误

```
#include <semaphore.h>

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

- `sem_timedwait()` 函数是 `sem_wait()` 的另一个变体，它允许调用者为调用被阻塞的时间量指定一个限制，如果 `sem_timedwait()` 调用因超时而无法递减信号量，那么这个调用就会失败并返回 `ETIMEDOUT` 错误

## 发布一个信号量

`sem_post()` 函数递增（增加 1）`sem` 引用的信号量的值。

```
#include <semaphore.h>

int sem_post(sem_t *sem);
```

- 如果在 `sem_post()` 调用之前信号量的值为 0，并且其他某个进程（或线程）正在因等待递减这个信号量而阻塞，那么该进程会被唤醒，它的 `sem_wait()` 调用会继续往前执行来递减这个信号量。
- 如果多个进程（或线程）在 `sem_wait()` 中阻塞了，并且这些进程的调度采用的是默认的循环时间分享策略，那么哪个进程会被唤醒并允许递减这个信号量是不确定的。（与 System V 信号量一样，POSIX 信号量仅仅是一种同步机制，而不是一种排队机制)

## 获取信号量的当前值

`sem_getvalue()` 函数将 `sem` 引用的信号量的当前值通过 `sval` 指向的 `int` 变量返回。

```
#include <semaphore.h>

int sem_getvalue(sem_t *sem, int *sval);
```

- 如果一个或多个进程(或线程)当前正在阻塞以等待递减信号量值，那么 `sval` 中的返回值将取决于实现：SUSV3 允许返回 0 或者一个绝对值等于 `sem_wait()` 阻塞的等待者数目的负数

- 在 `sem_getvalue()` 返回时，`sval` 中的返回值可能已经过时了。依赖于 `sem_getvalue()` 返回的信息在执行后续操作时未发生变化的程序将会碰到检查时、使用时（`time-of-check`、 `time-of-use`）的竞争条件

# 未命名信号量

























