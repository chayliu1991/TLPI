# 概述

信号量是用来同步进程和线程对共享资源的访问的。SUSv3规定了两种类型的 POSIX 信号量：

- 命名信号量：这种信号量拥有一个名字。通过使用相同的名字调用 `sem_open()`，不相关的进程能够访问同一个信号量
- 未命名信号量：这种信号量没有名字，相反，它位于内存中一个预先商定的位置处。当在进程间共享时，信号量必须位于同一个共享内存区域中。当在线程间共享时，信号量可以位于被这些线程共享的一块内存区域中(比如堆上或者一个全局变量中)

POSIX 信号量的运作方式与 System V 信号量类似，即 POSIX 信号量是一个整数，其值是不能小于 0 的。如果一个进程试图将一个信号量的值减少到小于0，那么取决于所使用的函数，调用会阻塞或返回一个表明当前无法执行相应操作的产物。

# 命名信号量

要使用命名信号量必须要使用下列函数：

- `sem_open()` 函数打开或者创建一个信号量并返回一个句柄以供后继调用使用，如果这个调用会创建信号量的话还会对所创建的信号量进行初始化
- `sem_post(sem)` 和 `sem_wait(sem)` 函数分别递增和递减一个信号量值
- `sem_getvalue()` 函数获取一个信号量的当前值
- `sem_close()` 函数删除调用进程与它之前打开的一个信号量之间的关联关系
- `sem_unlink()` 函数删除一个信号量名字并将其标记为在所有进程关闭该信号量时删除该信号量

SUSv3 并没有规定如何实现命名信号量。一些 UNIX 实现将它们创建成位于标准文件系统上一个特殊位置处的文件。在 Linux 上，命名信号量被创建成小型 POSIX 共享内存对象，其名字的形式为 `sem.name`，这些对象将被放在一个挂载在 `/dev/shm` 目录之下的专用 `tmpfs` 文件系统中。这个文件系统具备内核持久性，它包含的信号量对象将会持久，即使当前没有进程打开它们。除非系统被关闭，否则这些对象将一直存在。

## 打开一个命名信号量

`sem_open()` 函数创建和打开一个新的命名信号量或打开一个既有信号量。

```
#include <fcntl.h>        
#include <sys/stat.h> 
#include <semaphore.h>

sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);
```

- `name` 标识出了信号量
- `oflag ` 确定了是打开一个既有信号量还是创建并打开一个新信号量：

  - 如果  `oflag`  是 0，那么将访问一个既有信号量
  -  如果在 `oflag` 中指定了 `O_CREAT`，那么如果信号量尚不存在，则创建该信号量。
  - 如果 `O_CREAT` 和 `O_EXCL` 都在 `oflag` 中指定，那么如果具有给定名称的信号量已经存在，则返回错误，调用失败
- 如果 `sem_open()` 被用来打开一个既有信号量，那么调用就只需要两个参数。但如果在 `flags`  中指定了 `O_CREAT`，那么就还需要另外两个参数：`mode` 和 `value`
- `mode` 参数是一个位掩码，它指定了施加于新信号量之上的权限，并且与 `open()` 一样，`mode` 参数中的值会根据进程的 `umask` 来取掩码， 应该向将访问信号量的每一类用户授予读和写权限
- `value` 参数是一个无符号整数，它指定了新信号量的初始值。信号量的创建和初始化操作是原子的，这样就避免了 System V 信号量初始化时所需完成的复杂工作了

不管是创建一个新信号量还是打开一个既有信号量，`sem_open()` 都会返回一个指向一个 `sem_t` 值的指针，而在后续的调用中则可以通过这个指针来操作这个信号量。`sem_open()` 在发生错误时会返回 `SEM_FAILED` 值。

USv3 声称当在 `sem_open()` 的返回值指向的 `sem_t` 变量的副本上执行操作（`sem_post()`、`sem_wait()` 等）时结果是未定义的。换句话说，像下面这种使用 `sem2` 的做法是不允许的：

```
sem_t *sp, sem2;
sp = sem_open(...);
sem2 = *sp;
sem_wait(&sem2);
```

通过 `fork()` 创建的子进程会继承其父进程打开的所有命名信号量的引用。在 `fork()` 之后，父进程和子进程就能够使用这些信号量来同步它们的动作了。

## 关闭一个信号量

当一个进程打开一个命名信号量时，系统会记录进程与信号量之间的关联关系。`sem_close()` 函数会终止这种关联关系(关闭信号量)，释放系统为该进程关联到该信号量之上的所有资源，并递减引用该信号量的进程数。

```
#include <semaphore.h>

int sem_close(sem_t *sem);
```

打开的命名信号量在进程终止时或者进程执行了一个 `exec()` 时会自动被关闭。

关闭一个信号量并不会删除这个信号量，而要删除这个信号量则要使用 `sem_unlink()`。

## 删除一个命名信号量

`sem_unlink()` 函数删除通过 `name` 标识的信号量并将信号量标记成一旦所有进程都使用完这个信号量时就销毁该信号量。

```
#include <semaphore.h>

int sem_unlink(const char *name);
```

一旦所有其他打开信号量的进程关闭它，信号量就会被销毁。 

# 信号量操作

## 等待一个信号量

```
include <semaphore.h>

int sem_wait(sem_t *sem);
```

- `sem_wait()` 会将 `sem` 引用的信号量值减小1：
  - 如果信号量的当前值大于 0，那么 `sem_wait()` 会立即返回
  - 如果信号量的当前值等于 0，那么 `sem_wait()` 会阻塞直到信号量的值大于 0 为止
- 如果一个阻塞的 `sem_wait()` 调用被一个信号处理器中断了，那么它就会失败并返回 `EINTR` 错误，不管在使用 `sigaction()` 建立这个信号处理器时是否采用了 `SA_RESTART` 标记。（在其他一些 UNIX 实现上，`SA_RESTART` 会导致 `sem_wait()` 自动重启。）

```
#include <semaphore.h>

int sem_trywait(sem_t *sem);
```

- `sem_trywait()` 函数是 `sem_wait()` 的一个非阻塞版本。如果递减操作无法立即被执行，那么 `sem_trywait()` 就会失败并返回 `EAGAIN` 错误

```
#include <semaphore.h>

int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

- `sem_timedwait()` 函数是 `sem_wait()` 的另一个变体，它允许调用者为调用被阻塞的时间量指定一个限制，如果 `sem_timedwait()` 调用因超时而无法递减信号量，那么这个调用就会失败并返回 `ETIMEDOUT` 错误

## 发布一个信号量

`sem_post()` 函数递增（增加 1）`sem` 引用的信号量的值。

```
#include <semaphore.h>

int sem_post(sem_t *sem);
```

- 如果在 `sem_post()` 调用之前信号量的值为 0，并且其他某个进程（或线程）正在因等待递减这个信号量而阻塞，那么该进程会被唤醒，它的 `sem_wait()` 调用会继续往前执行来递减这个信号量。
- 如果多个进程（或线程）在 `sem_wait()` 中阻塞了，并且这些进程的调度采用的是默认的循环时间分享策略，那么哪个进程会被唤醒并允许递减这个信号量是不确定的。（与 System V 信号量一样，POSIX 信号量仅仅是一种同步机制，而不是一种排队机制)

## 获取信号量的当前值

`sem_getvalue()` 函数将 `sem` 引用的信号量的当前值通过 `sval` 指向的 `int` 变量返回。

```
#include <semaphore.h>

int sem_getvalue(sem_t *sem, int *sval);
```

- 如果一个或多个进程(或线程)当前正在阻塞以等待递减信号量值，那么 `sval` 中的返回值将取决于实现：SUSV3 允许返回 0 或者一个绝对值等于 `sem_wait()` 阻塞的等待者数目的负数

- 在 `sem_getvalue()` 返回时，`sval` 中的返回值可能已经过时了。依赖于 `sem_getvalue()` 返回的信息在执行后续操作时未发生变化的程序将会碰到检查时、使用时（`time-of-check`、 `time-of-use`）的竞争条件

# 未命名信号量

未命名信号量(也被称为基于内存的信号量)是类型为 `sem_t` 并存储在应用程序分配的内存中的变量。通过将这个信号量放在由几个进程或者线程共享的内存区域中就能使得这个信号量对这些进程或者线程可用。

操作未命名信号量所使用的函数与操作命名信号量使用的函数是一样的（`sem_wait()`、`sem_post()` 以及 `sem_getvalue()` 等）。此外，还需要用到另外两个函数：

- `sem_init()` 对一个信号量进行初始化并通知系统该信号量会在在进程间共享还是在单个进程中的线程间共享
- `sem_destroy(sem)` 函数销毁一个信号量

这些函数不应该被应用到命名信号量上。

未命名与命名信号量对比：

使用未命名信号量之后就无需为信号量创建一个名字了，这种做法在下列情况中是比较有用的：

- 在线程间共享的信号量不需要名字。将一个未命名信号量作为一个共享（全局或堆上的）变量自动会使之对所有线程可用
- 在相关进程间共享的信号量不需要名字。如果一个父进程在一块共享内存区域中（如一个共享匿名映射）分配了一个未命名信号量，那么作为 `fork()` 操作的一部分，子进程会自动继承这个映射，从而继承这个信号量
- 如果正在构建的是一个动态数据结构，例如二叉树，并且其中的每一项都需要有一个关联的信号量，那么最简单的做法是在每一项中都分配一个未命名信号量

## 初始化一个未命名信号量

`sem_init()` 函数使用 `value` 对 `sem` 指定的未命名信号量进行初始化。

```
#include <semaphore.h>

int sem_init(sem_t *sem, int pshared, unsigned int value);
```

- `pshared` 表明这个信号量是在线程间共享还是在进程间共享：
  - 如果 `pshared` 等于0，那么信号量会在调用进程中的线程间共享。此时，`sem` 通常被指定成一个全局变量的地址会在分配在堆上的一个变量的地址。线程共享的信号量具有进程持久性，它在进程终止时会被销毁
  - 如果 `pshared` 不等于0，那么信号会在进程间共享。此时，`sem` 必须是共享内存区域（一个 POSIX 共享内存对象、一个使用 `mmap()` 创建的共享映射、或一个 System V 共享内存段）中的某个位置的地址。信号量的持久性与它所处的共享内存的持久性是一样的。（通过其中大部分技术创建的共享内存区域具备内核持久性。但共享匿名映射是一个例外，只要存在一个进程维持着这种映射，那么它就一直存在下去。）由于 `fork()` 创建的子进程会继承其父进程的内存映射，因此进程共享的信号量会被通过 `fork()` 创建的子进程继承。这样父子进程间就能够使用这些信号量来同步它们的工作了
- 之所以需要 `pshared` 参数是因为如下原因：
  - 一些实现不支持进程间共享的信号量。在这些系统上为 `pshared` 指定一个非零值会导致 `sem_init()` 返回一个错误。Linux 直到内核 2.6 以及 NPTL 线程化技术的出现之后才开始支持未命名的进程间共享的信号量。（在老式的 LinuxThreads 实现中，如果为 `pshared` 指定了一个非零值，那么 `sem_init()` 就会失败并返回一个 `ENOSYS` 错误。）
  - 在同时支持进程间共享信号量和线程间共享信号量的实现上，指定采用何种共享方式是有必要的，因为系统必须要执行特殊的动作来支持所需的共享方式。提供此类信息还使得系统能够根据共享的种类来执行优化工作
- 未命名信号量不存在相关的权限设置（即 `sem_init()` 中并不存在在 `sem_open()` 中所需的 `mode` 参数）。对一个未命名信号量的访问将由进程在底层共享内存区域上的权限来控制
- SUSv3 规定对一个已初始化过的未命名信号量进行初始化操作将会导致未定义的行为。换句话说，必须要将应用程序设计成只有一个进程或线程来调用 `sem_init()` 以初始化一个信号量
- 与命名信号量一样，SUSv3 声称在地址通过传入 `sem_init()` 的 `sem` 参数指定的 `sem_t` 变量的副本上执行操作的结果是未定义的，因此应该总是只在“最初的”信号量上执行操作

## 销毁一个未命名信号量

`sem_destroy()` 将消耗信号量 `sem`，其中 `sem` 必须是一个之前使用 `sem_init()` 进行初始化的未命名信号量。只有不存在进程或者线程在等待一个信号量时才能安全消耗这个信号量。

```
#include <semaphore.h>

int sem_destroy(sem_t *sem);
```

- 当使用 `sem_destory()` 销毁了一个未命名信号量之后就能够使用 `sem_init()` 来重新初始化这个信号量了
- 一个未命名信号量应该在其底层的内存被释放之前被消耗。例如，如果信号量一个自动分配的变量，那么在其宿主函数返回之前就应该销毁这个信号量。如果信号量位于一个 POSIX 共享内存区域中，那么在所有进程都使用完这个信号量以及在使用 `shm_unlink()` 对这个共享内存对象执行断开链接操作之前应该销毁这个信号量
- 在一些实现上，省略 `sem_destroy()` 调用不会导致问题的发生，但在其他实现上，不调用 `sem_destroy()` 会导致资源泄露。可移植的应用程序应该调用 `sem_destroy()` 以避免此类问题的发生

# 与其他同步技术比较

## POSIX 信号量与 System V 信号量

优点：

- POSIX IPC 接口更加简单并且与传统的 UNIX 文件模型更加一致
- POSIX IPC 对象是引用计数的，这样就简化了确定何时删除一个 IPC 对象的工作
- POSIX 命名信号量消除了 System V 信号量存在的初始化问题(首先，进程 B 在一个未初始化的信号量（即其值是一个任意值）上执行了一个 `semop()`。其次，进程 A 中的 `semctl()` 调用覆盖了进程 B 所做出的变更)
- 将一个 POSIX 未命名信号量与动态分配的内存对象关联起来更加简单：只需要将信号量嵌入到对象中即可
- 在高度频繁地争夺信号量的场景中，那么 POSIX 信号量的性能与System V 信号量的性能是类似的。但在争夺信号量不那么频繁的场景中，POSIX 信号量的性能要比 System V 信号量好很多。POSIX 在这种场景中之所以能够做得更好是因为它们的实现方式只有在发生争夺的时候才需要执行系统调用，而 System V 信号量操作则不管是否发生争夺都需要执行系统调用。

缺点：

- POSIX 信号量的可移植性稍差
- POSIX 信号量不支持 System V 信号量中的撤销特性。(然而这个特性在一些场景中可能并没有太大的用处。)

## POSIX 信号量与 Pthreads 互斥体

POSIX 信号量和 Pthreads 互斥体都可以用来同步同一个进程中的线程的动作，并且它们的性能也是相近的。然而互斥体通常是首选方法，因为互斥体的所有权属性能够确保代码具有良好的结构性（只有锁住互斥体的线程才能够对其进行解锁）。与之形成对比的是，一个线程能够递增一个被另一个线程递减的信号量。这种灵活性会导致产生结构糟糕的同步设计。

# 信号量的限制

- `SEM_NSEMS_MAX` ： 这是一个进程能够拥有的 POSIX 信号量的最大数目
- `SEM_VALUE_MAX` ：这是一个 POSIX 信号量值能够取的最大值。信号量的取值可以为 0 到这个限制之间的任意一个值





































