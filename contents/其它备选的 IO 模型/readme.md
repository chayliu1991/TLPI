# 整体概览

对于一般应用，传统的阻塞式 IO 模型已经足够了，但这不代表所有的应用都能得到满足。特别地，有些应用需要处理以下某项任务，或者两者都要兼顾：

- 如果可能的话，以非阻塞的方式检查文件描述符上是否可进行 IO 操作
- 同时检查多个文件描述符，看它们中的任何一个是否可以执行 IO 操作

解决方案有两种：非阻塞式 IO 和多进程或多线程技术，它们的局限：

- 非阻塞式 IO 可以周期性的检查某个文件描述符上是否可执行 IO 操作，但是紧凑的循环中做轮询就是在浪费 CPU
- 多进程的劣势是比较大开销，创建及维护进程对系统来说都有开销，而一般来说子进程需要使用某种 IPC 机制来通知父进程有关 IO 操作的状态
- 使用多线程可以占用较少资源，但是线程之间仍然需要通信，这将使得编程工作变得复杂

由于非阻塞 IO 和多线程多进程技术的局限，下列的方案更加可取：

- IO 多路复用允许进程同时检查多个文件描述符以找出它们的任何一个是否可执行 IO 操作，系统调用 `select()` 和 `poll()` 用来执行 IO 多路复用
- 信号驱动 IO 是指当有输入或者数据可以写到指定的文件描述符上时，内核向请求数据的进程发送一个信号，当同时检查大量的文件描述符时，信号驱动 IO 相比于 `select()` 和 `poll()` 有显著的性能提升
- `epoll()` 是 Linux 专有特性，当同时检查大量文件描述符时，`epoll()` 能够提供更好的性能

IO 多路复用，信号驱动 IO 以及 epoll 都是为了实现：同时检查多个文件描述符，看他们是否准备好了执行 IO 操作，也可以理解为，看 IO 系统调用是否可以非阻塞地执行。文件描述符就绪状态的转化是通过一些 IO 事件来触发的，比如：输入数据到达，套接字建立完成，满载的套接字发送缓冲区在 TCP 队列中的数据传输到对端之后有了剩余空间。

## 选择哪种技术

`select()` 和 `poll()` 的优点是可移植性，主要缺点是同时检查大量的(数百或者数千)文件描述符时性能延展性不佳。

`epoll()` 优势在于它能让应用程序高效地检查大量的文件描述符，缺点是它是 Linux 专有的系统 API。

信号驱动 IO 也能如 `epoll()` 一样让应用程序高效地检查大量的文件描述符，但是 `epoll()` 有一些信号驱动 IO 所没有的优点：

- 避免了处理信号的复杂性
- 可以指定想要检查的事件类型(如读就绪还是写就绪)
- 可以选择水平触发还是边缘触发的方式来通知进程

## 水平触发和边缘触发

两种文件描述符准备就绪的通知模式：

- 水平触发通知：如果文件描述符上可以非阻塞地执行 IO 系统调用，此时认为它已经就绪
- 边缘触发通知：如果文件描述符自上次状态检查以来有了新的 IO 活动，此时需要触发通知

![](./img/trigger.png)

当采用水平触发通知时，可以在任意时刻检查文件描述符的就绪状态，这表示当确定了文件描述符处于就绪，就可以对其执行一些 IO 操作，然后重复检查文件描述符，看是否处于就绪状态。

当采用边缘触发时，只有当 IO 事件发生时才会收到通知，在另一个 IO 事件到来之前不会收到任何新的通知。另外，当文件描述符收到 IO 事件通知时，通常并不知道要处理多少 IO，因此采用边缘触发通知的程序，需要按照如下规则来设计：

- 当接收到一个 IO 事件通知后，程序在某个时刻应该在相应的文件描述符上尽可能多地执行 IO，如果程序没有这么做，那么可能就会失去执行 IO 的机会。因为直到产生另一个 IO 事件为止，在此之前程序不会再接收到通知，因此也就不知道此时应该执行 IO 操作，这将导致数据丢失或者程序中出现阻塞
- 如果程序采用循环来对文件描述符执行尽可能多的 IO，而文件描述符又被设置为可阻塞的，那么最终当没有更多的 IO 可执行时，IO 系统调用就会阻塞，基于这个原因，每个被检查的文件描述符通常都应该设置为非阻塞模式，在得到 IO 事件通知后重复执行 IO 操作，直到相应的系统调用(如 `read()`  或者 `write()` ) 以错误码 `EAGAIN` 或者 `EWOULDBLOCK`  的形式失败

## 在备选的 IO 模型中采用非阻塞 IO

非阻塞 IO(`O_NONBLOCK` 标志)的好处：

- 非阻塞 IO 通常和提供有边缘触发通知机制的 IO 模型一起使用
- 如果多个进程或者多个线程在同一个打开的文件描述符上执行 IO 操作，那么从某个特定进程的角度来看，文件描述符的就绪状态可能会在通知就绪和执行后续 IO 调用之间发生改变。结果就是一个阻塞式的 IO 调用将阻塞，从而防止进程检查其他的文件描述符
- 尽管水平触发模式的 API 比如 `select()` 或 `poll()` 通知流式套接字的文件描述符已经写就绪了，如果在单个 `write()` 或者 `send()` 调用中写入足够大块的数据，那么该调用将阻塞
- 在非常罕见的情况下，水平触发型的 API 比如 `select()` 和 `poll()`，会返回虚假的就绪通知，它们会错误地通知文件描述符已经就绪了，这可能是由内核 bug 造成的，或者非普通情况下的设计方案所期望的行为

# IO 多路复用

##  `select()` 系统调用



## `poll()` 系统调用



## 文件描述符何时就绪



## 比较 `select()` 和 `poll()`



## `select()` 和 `poll()` 存在的问题













































