# 间隔定时器

```
#include <sys/time.h>

int setitimer(int which,const struct itimerval* new_value,struct itimerval* old_value);
```

- `setitimer()` 创建一个间隔式定时器，这种定时器会在未来某个时间点到期，并于此后(可选择地)每间隔一段时间到期一次
- `which` 可以指定以下值：
  - `ITIMER_REAL` ：创建以真实时间倒计时的定时器，到期会产生 `SIGALARM`  信号并发送给进程
  - `ITIMER_VIRTUAL`：创建以进程虚拟时间(用户模式下的 CPU 时间) 倒计时的定时器，到期时会产生信号 `SIGVTALRM`
  - `ITIMER_PROF`：创建一个 `profiling` 定时器，以进程时间(用户态与内核态 CPU 时间的总和)倒计时，到期时，则会产生 `SIGPROF` 信号

针对所有这些信号的默认处置均会终止进程，除非真地期望如此，否则就需要针对这些定时器信号创建处理器函数。

```
struct itimerval{
	struct timeval it_interval;	/* Interval for periodic timer */
	struct timeval it_value;	/* Current value(time until next expiration) */
};

struct timeval{
	time_t tv_sec;		/* Seconds */
	suseconds_t tv_usec;	/* Microseconds */
};
```

- `new_value` 下属的 `it_value` 指定了距离定时器到期的延迟时间，`it_interval` 则说明该定时器是否是周期性定时器，如果 `it_interval` 的两个字段都是 0，那么该定时器属于 `it_value` 所指定的时间间隔后到期的一次性定时器，只要 `it_interval` 中的任一字段非0，那么在每次定时器到期之后，都会将定时器重置为在指定间隔后再次到期
- 进程只能拥有上述3种定时器的一种，当第二次调用 `settimer()`  时，修改已有定时器的属性要符合参数 `which` 中的类型，如果调用 `setitimer()` 时将 `new_value.it_value` 的两个字段均设置为 0，那么会屏蔽任何已有的定时器
- 若 `old_value` 不为 `NULL`，则以其所指向的 `itimerval` 结构来返回定时器的前一设置：
  - 如果 `old_value.it_value` 的两个字段值均为 0，那么该定时器之前被设置处于屏蔽状态
  - 如果 `old_value.it_interval` 的两个字段值均为 0，那么该定时器之前被设置为历经 `old_value.it_value` 指定时间到期的一次性定时器
  - 对需要在新定时器到期后将其还原的情况而言，获取定时器的前一设置就很重要，如果不关心定时器的前一设置，可以将 `old_value` 设置为 `NULL`
- 定时器会从初始值 `it_value` 倒计时一直到 0 为止，递减为 0 时，会将相应信号发送给进程，随后，如果时间间隔值 `it_interval` 非0，那么会再次将 `it_value` 加载到定时器，重新开始向 0 倒计时

可以在任何时刻调用 `getitimer()`，以了解定时器的当前状态，距离下次到期的剩余时间：

```
#include <sys/time.h>

int getitimer(int which,struct itimerval* curr_value);
```































