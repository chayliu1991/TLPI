# 概述

管道最常见的地方是shell中，比如：

```
$ ls | wc -l
```

为了执行上面的命令，shell创建了两个进程来分别执行 `ls` 和 `wc` (通过 `fork()` 和 `exec()` 完成)，如下：

![](./img/ls_wc.png)

从上图可以看出，可以将管道看成是一组水管，它允许数据从一个进程流向另一个进程，这也是管道名称的由来。

从上图可以看出，由两个进程连接到了管道上，这样写入进程 `ls` 就将其标准输出(文件描述符为1)连接到来管道的写入段，读取进程 `wc` 就将其标准输入(文件描述符为0)连接到管道的读取端。实际上，这两个进程并不知道管道的存在，它们只是从标准文件描述符中读取和写入数据。shell 必须要完成相关的工作。

## 一个管道是一个字节流

管道是一个字节流，即在使用管道时是不存在消息或者消息边界的概念的：

- 从管道中读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是什么
- 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序与它们被写入管道的顺序是完全一样的，在管道中无法使用 `lseek()` 来随机的访问数据

如果需要在管道中实现离散消息的概念，那么就必须要在应用程序中完成这些工作。虽然这是可行的，但如果碰到这种需求的话最好使用其他 IPC 机制，如消息队列和数据报 socket。

## 从管道中读取数据

试图从一个当前为空的管道中读取数据将会被阻塞直至至少有一个字节被写入到管道中为止。

如果管道的写入端被关闭了，那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束（即 `read()` 返回 0）。

## 管道是单向的

在管道中数据的传递方向是单向的。管道的一端用于写入，另一端则用于读取。

在其他一些 UNIX 实现上，特别是那些从 System V Release 4 演化而来的系统，管道是双向的（所谓的流管道）。双向管道并没有在任何 UNIX 标准中进行规定，因此即使在提供了双向管道的实现上最好也避免依赖这种语义。作为替代方案，可以使用 UNIX domain 流 socket 对（通过 `socketpair()` 系统调用来创建），它提供了一种标准的双向通信机制，并且其语义与流管道是等价的。

## 可以确保写入不超过 PIPE_BUF 字节的操作是原子的

如果多个进程写入同一个管道，那么如果它们在一个时刻写入的数据量不超过 PIPE_BUF 字节，那么就可以确保写入的数据不会发生相互混合的情况。

SUSv3 要求 PIPE_BUF 至少为 `_POSIX_PIPE_BUF(512)`。一个实现应该定义 PIPE_BUF（在 `<limits.h>` 中）并/或允许调用 `fpathconf(fd,_PC_PIPE_BUF)` 来返回原子写入操作的实际上限。
不同 UNIX 实现上的 PIPE_BUF 不同，如在 FreeBSD 6.0 其值为 512 字节，在 Tru64 5.1 上其值为 4096 字节，在 Solaris 8 上其值为 5120 字节。在 Linux 上，PIPE_BUF 的值为 4096。

- 当写入管道的数据块的大小超过了 PIPE_BUF 字节，那么内核可能会将数据分割成几个较小的片段来传输，在读者从管道中消耗数据时再附加上后继的数据(`write()`调用会阻塞直到所有数据被写入到管道为止)
- 当只有一个进程向管道写入数据时（通常的情况），PIPE_BUF 的取值就没有关系了
- 但如果有多个写入进程，那么大数据块的写入可能会被分解成任意大小的段（可能会小于 PIPE_BUF 字节），并且可能会出现与其他进程写入的数据交叉的现象

只有在数据被传输到管道的时候 PIPE_BUF 限制才会起作用。当写入的数据达到 PIPE_BUF 字节时，`write()` 会在必要的时候阻塞知道管道中的可用空间足以原子的完成此操作。如果写入的数据大于 PIPE_BUF 字节，那么 `write()` 会尽可能的多传输数据以充满整个管道，然后阻塞直到一些读取进程从管道中移除了数据。如果此类阻塞的 `write()` 被一个信号处理器中断了，那么这个调用会被解除阻塞并返回成功传输到管道中的字节数，这个字节数会少于请求写入的字节数（所谓的部分写入）。

## 管道的容量是有限的

管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满之后，后继向管道的写入操作就会被阻塞直到读者从管道中移除了一些数据为止。

SUSv3 并没有规定管道的存储能力。在早于 2.6.11 的 Linux 内核中，管道的存储能力与系统页面的大小是一致的（如在 x86-32 上是 4096 字节），而从 Linux 2.6.11 起，管道的存储能力是 65,536 字节。其他 UNIX 实现上的管道的存储能力可能是不同的。

一般来讲，一个应用程序无需知道管道的实际存储能力。如果需要防止写者进程阻塞，那么从管道中读取数据的进程应该被设计成以尽可能快的速度从管道中读取数据。

# 创建和使用管道

```
#include <unistd.h>

int pipe(int fd[2]);    
```

- `pipe()` 创建一个新管道
- 成功的调用在数组 `fd` 中返回两个打开的文件描述符，一个表示管道的读取端 `fd[0]`，一个表示管道的写入端 `fd[1]`

调用 `pipe()` 函数时，首先在内核中开辟一块缓冲区用于通信，它有一个读端和一个写端，然后通过 `fd` 参数传出给用户进程两个文件描述符，`fd[0]` 指向管道的读端，`fd[1]` 指向管道的写段。

不要用 `fd[0]` 写数据，也不要用 `fd[1]` 读数据，其行为未定义的，但在有些系统上可能会返回 -1 表示调用失败。数据只能从 `fd[0]` 中读取，数据也只能写入到`fd[1]`，不能倒过来。

与所有文件描述符一样，可以使用 `read()` 和  `write()` 系统调用来在管道上执行 IO，一旦向管道的写入端写入数据之后立即就能从管道的读取端读取数据。管道上的 `read()`  调用会读取的数据量为所请求的字节数与管道中当前存在的字节数两者之间的较小值。当管道为空时，读取操作阻塞。

也可以在管道上使用 stdio 函数（`printf()`、`scanf()` 等），只需要首先使用 `fdopen()` 获取一个与 `filedes` 中的某个描述符对应的文件流即可。但在这样做的时候需要解决 `stdio` 缓冲问题。

管道可以用于进程内部自己通信：

![](./img/pipe.png)

管道可以用于亲缘关系(子进程会继承父进程中的文件描述符的副本)进程中通信：

![](./img/pipe_parent_child.png)

不建议将单个 pipe 用作全双工的，或者不关闭用作半双工而不关闭相应的读端/写端，这样很可能导致死锁：如果两个进程同时试图从管道中读取数据，那么就无法确定哪个进程会首先读取成功，从而产生两个进程竞争数据了。要防止这种竞争情况的出现就需要使用某种同步机制。这时，就需要考虑死锁问题了，因为如果两个进程都试图从空管道中读取数据或者尝试向已满的管道中写入数据就可能会发生死锁。

如果我们想要一个双向数据流时，可以创建两个管道，每个方向一个。

## 管道允许相关进程间的通信

其实管道可以用于任意两个甚至更多相关进程之间的通信，只要在创建子进程的系列 `fork()` 调用之前通过一个共同的祖先进程创建管道即可。

## 关闭未使用管道文件描述符

关闭未使用管道文件描述符不仅仅是为了确保进程不会消耗尽其文件描述符的限制。

从管道中读取数据的进程会关闭其持有的管道的写入描述符，这样当其他进程完成输出并关闭其写入描述符之后，读者就能够看到文件结束。反之，如果读取的进程没有关闭管道的写入端，那么在其他进程关闭了写入描述符之后，即使读者已经读完了管道中的所有数据，也不会看到文件结束。因为此时内核知道至少还有一个管道的写入描述符打开着，从而导致 `read()` 阻塞。

当一个进程视图向一个管道中写入数据但没有任何进程拥有该管道的打开着的读取描述符时，内核会向写入进程发送一个 `SIGPIPE` 信号，默认情况下，这个信号将会杀死进程，但进程可以选择忽略或者设置信号处理器，这样 `write()` 将因为 `EPIPE` 错误而失败。收到 `SIGPIPE` 信号和得到 `EPIPE`  错误对于标识管道的状态是有意义的，这就是为什么需要关闭管道的未使用读取描述符的原因。如果写入进程没有关闭管道的读取端，那么即使在其他进程已经关闭了管道的读取端之后，写入进程仍然能够向管道写入数据，最后写入进程会将数据充满整个管道，后续的写入请求会将永远阻塞。























