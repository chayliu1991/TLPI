共享内存允许两个或多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。速度比起管道或者消息队列更快。

另一方面，共享内存这种 IPC 机制不由内核控制意味着需要通过某些同步方法使得不会出现同时访问共享内存的情况。System V 信号量就是天生用来实现这种同步的方法。当然，还可以使用其他方法，比如 POSIX 信号量和文件锁。

# 概述

为使用一个共享内存段通常需要执行下面的步骤：

- 调用 `shmget()` 创建一个新共享内存段或者取得一个既有共享内存段的标识符
- 使用 `shmat()` 来附上共享内存段，即令该段成为调用进程的虚拟内存的一部分
- 此时在程序中就可以向对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 `shmat()` 调用返回的 `addr` 值。它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针
- 调用 `shmdt()` 来分离这个共享段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步
- 调用 `shmctl()` 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会被销毁。只有一个进程需要执行这一步

# 创建或打开一个共享内存段

```
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int shmflg);
```

- `shmget()` 系统调用创建一个新共享内存或获取一个既有段的标识符。新创建的内存段中的内容会被初始化为 0
- `key`：通常是值 `IPC_PRIVATE` 或 `ftok()` 返回的一个键
- `size`：当使用 `shmget()` 创建一个新共享内存段时，`size` 则是一个正整数，它表示需分配的段的字节数。内核是以系统分页大小的整数倍来分配共享内存的，因此实际上 `size` 会提升到最近的系统分页大小的整数倍。如果使用 `shmget()` 来获取一个既有段的标识符，那么 `size` 对段不会产生任何效果，但是它必须小于等于段的大小
- `shmflg` 参数执行的任何与其他 IPC `get` 调用中执行的任务一样，即指定施加于新共享内存段上的权限或需检查的既有内存段的权限。此外，在 `shmflg` 中还可以对下列标记中的零个或多个取 `OR` 来控制 `shmget()` 的操作：
  - IPC_CREAT ：如果不存在与指定的 key 对应的段，那么就创建一个新段。
  - IPC_EXCL ：如果同时指定了IPC_CREAT 并且与指定的key 对应的段已经存在，那么返回EEXIST 错误
  - SHM_HUGETLB（自 Linux 2.6 起）：
    - 特权（CAP_IPC_LOCK）进程能够使用这个标记创建一个使用巨页（huge page）的共享内存段。
    - 巨页是很多现代硬件架构提供的一项特性用来管理使用超大分页尺寸的内存。（如 x86-32 允许使用 4MB 的分页大小来替代 4KB 的分页大小。）
    - 在那些拥有大量内存的系统上并且应用程序需要大量内存块时，使用巨页可以降低硬件内存管理单元的超前转换缓冲区器（translation look-aside buffer，TLB）的数量
  - SHM_NORESERVE（自 Linux 2.6.15 起）：这个标记在 shmget()中所起的作用与MAP_NORESERVE 标记在 mmap()中所起的作用一样



















