# 改变内存保护

```
#include <sys/mman.h>

int mprotect(void *addr, size_t len, int prot);
```

- `mprotect()` 修改起始位置为 `addr` 长度为 `length` 字节的虚拟内存区域中分页上的保护
- `addr` 的取值必须是系统分页大小（`sysconf(_SC_PAGESIZE)` 的返回值）的整数倍。由于保护是设置在整个分页上的，因此实际上 `length` 会被向上舍入到系统分页大小的下一个整数倍
- `prot` 参数是一个位掩码，它指定了这块内存区域上的新保护，其取值是 `PROT_NONE` 或 `PROT_READ`、`PROT_WRITE`、以及 `PROT_EXEC` 这三个值中的一个或多个取 `OR`。所有这些值的含义与它们在 `mmap()` 中的含义是一样的
- 如果一个进程在访问一块内存区域时违背了内存保护，那么内核就会向该进程发送一个 `SIGSEGV` 信号

# 内存锁

在一些应用程序中将一个进程的虚拟内存的部分或者全部锁进内存以确保它们总是位于物理内存是非常有用的。之所以需要这样做的一个原因是它可以提高性能。对被锁住的分页的访问可以确保永远不会因为分页故障而发生延迟。

给内存加锁的另一个原因是安全。如果一个包含敏感信息的虚拟内存分页永远也不会被交换出去，那么该分页的副本就不会被写入磁盘(攻击者可能会故意通过运行一个消耗大量内存的程序来构造这种场景，从而强制其他进程占据的内存被交换到磁盘上。)

## `RLIMIT_MEMLOCK` 资源限制

`RLIMIT_MEMLOCK` 为一个进程能够锁进内存的字节数设定了一个上限。

在 2.6.9 之前的 Linux 内核中，只有特权进程（`CAP_IPC_LOCK`）才能给内存加锁，`RLIMIT_MEMLOCK` 软资源限制为一个特权进程能够锁住的字节数设定一个上限。

从 Linux 2.6.9 开始，内存加锁模型发生了变化，即允许非特权进程给一小段内存进行加锁：

- 特权进程能够锁住的内存数量是没有限制的（即 `RLIMIT_MEMLOCK` 会被忽略）
- 非特权进程能够锁住的内存数量上限由软限制 `RLIMIT_MEMLOCK` 定义

软和硬 `RLIMIT_MEMLOCK` 限制的默认值都是 8 个分页（即在 x86-32 上是 32768 字节）。

`RLIMIT_MEMLOCK` 限制影响：

- `mlock()` 和 `mlockall()`
- `mmap() MAP_LOCKED` 标记，该标记用来在映射被创建时将内存映射锁进内存
- `shmctl() SHM_LOCK` 操作，该操作用来给 System V 共享内存段加锁

由于虚拟内存的管理单位是分页，因此内存加锁会应用于整个分页。在执行权限检测时，`RLIMIT_MEMLOCK` 限制会被向下舍入到最近的系统分页大小的整数倍。

`RLIMIT_MEMLOCK`  实际上定义了两个单独的限制：

- 对于 `mlock()`，`mlockall()`  以及  `mmap() MAP_LOCKED`  操作来说，`RLIMIT_MEMLOCK` 定义了一个进程级别的限制，它限制了一个进程的虚拟地址空间中能够被锁进内存的字节数
- 对于 `shmctl() SHM_LOCK` 操作来说，  `RLIMIT_MEMLOCK`  定义了一个用户级别的限制，它限制了这个进程的真实用户 ID 在共享内存段中能够锁住的字节数，当一个进程执行了一个 `shmctl() SHM_LOCK` 操作时，内核会检查被调用进程的真实用户ID 锁住的 System V 共享内存的总字节数，如果待加锁的段的大小不会导致总量违背进程的  `RLIMIT_MEMLOCK`  限制，那么操作就会成功

## 给内存区域加锁和解锁

一个进程可以使用 `mlock()` 和 `munlock()` 来给一块内存区域加锁和解锁。

```
#include <sys/mman.h>

int mlock(const void *addr, size_t len);
int munlock(const void *addr, size_t len);
```

- `mlock()` 系统调用会锁住调用进程的虚拟地址空间中起始地址为 `addr` 长度为 `length` 字节的区域中的所有分页
- 由于加锁操作的单位是分页的，因此被锁住的区域的结束位置为大于 `length`  加 `addr` 的下一个页边界
- 在 `mlock()` 调用成功之后就能确保指定区域中的分页会被锁住并驻留在物理内存中。当没有足够的物理内存来锁住所有所请求的分页或请求违背 `RLIMIT_MEMLOCK` 软资源限制时 `mlock()` 系统调用就会失败
- `munlock()` 删除之前由调用进程创建的内存锁。给一组分页解锁并不能确保它们就不会驻留在内存中了，只有在其他进程请求内存的时候才会从 RAM 中删除分页

除了显式地使用 `munlock()` 之外，内存锁在下列情况下会被自动删除：

- 在进程终止时
- 当被锁住的分页通过 `munmap()` 被解除映射时
- 当被锁住的分页被使用 `mmap() MAP_FIXED` 标记的映射覆盖时

## 内存加锁语义的细节信息

内存锁不会被通过 `fork()` 创建的子进程继承，也不会在 `exec()` 执行期间被保留。

当多个进程共享一组分页时（如 `MAP_SHARED` 映射），只要还存在一个进程持有着这些分页上的内存锁，那么这些分页就会保持被锁进内存的状态。

内存锁不在单个进程上叠加。如果一个进程重复地在一个特定虚拟地址区域上调用 `mlock()`，那么只会建立一个锁，并且只需要通过一个 `munlock()` 调用就能够删除这个锁。另一方面，如果使用 `mmap()` 将同一组分页（即同样的文件）映射到单个进程中的几个不同的位置，然后分别给所有这些映射加锁，那么这些分页会保持被锁进 RAM 的状态直到所有的映射都被解锁为止。

内存锁的加锁单位为分页以及无法叠加的事实意味着独立地将 `mlock()` 和 `munlock()` 调用应用于同一个虚拟分页上的不同数据结构在逻辑上是不正确的。

假设在同一个虚拟内存分页中存在两个数据结构，`p1` 和 `p2` 分别指向了这两个结构：

```
mlock(*p1,len1);
mlock(*p2,len2);
munlock(*p1,len1);
```

上面的调用都会成功，但最后整个分页都会被解锁，即 `p2` 指向的数据结构将不会被锁进内存。

注意 `shmctl() SHM_LOCK` 操作的语义和 `mlock()` 和 `mlockall()` 的语义是不同的：

- `SHM_LOCK` 操作之后，分页只有在因后续引用而发生故障时才会被锁进内存，`mlock()` 和 `mlockall()` 调用会在返回之前将所有分页锁进内存
- `SHM_LOCK`  操作会设置共享内存段的一个属性，而不是进程的属性，这意味着分页一旦因故障被缩进了内存，那么即使所有进程都与这个共享内存段分离了，分页还是会保持驻留在内存中的状态，`mlock()` 和 `mlockall()` 调用锁进内存的区域只有在还存在进程持有该区域上的锁时才会保持被锁进内存的状态

### 给一个进程占据的所有内存加锁和解锁

一个进程可以使用 `mlockall()` 和 `munlockall()` 给它占据的所有内存加锁和解锁。

```
#include <sys/mman.h>

int mlockall(int flags);
int munlockall(void);
```

- `flags` 参数的取值为下面这些常量中的一个或多个取 `OR`:

- `MCL_CURRENT`：将调用进程的虚拟地址空间中当前映射的分页锁进内存，包括当前为程序文本段、数据段、内存映射以及栈分配的所有分页
- `MCL_FUTURE `：将后继映射进调用进程的虚拟地址空间的所有分页锁进内存。例如，此类分页可能是通过 `mmap()` 或 `shmat()` 映射的一个共享内存区域的一部分，或向上增长的堆或向下增长的栈的一部分。指定 `MCL_FUTURE` 标记的结果是后续的内存分配操作（如 `mmap()`、`sbrk()` 或 `malloc()`）可能会失败，或者栈增长可能会产生 `SIGSEGV` 信号，当然前提是系统已经没有 RAM 分配给进程或者已经达到了 `RLIMIT_MEMLOCK` 软资源限制

- 通过 `mlock()` 创建的内存锁上有关约束、生命周期以及继承性方面的规则同样也适用于通过 `mlockall()` 创建的内存锁。

- `munlockall()` 系统调用将调用进程的所有分页解锁并撤销之前的 `mlockall(MCL_ FUTURE)` 调用所产生的结果。与 `munlock()` 一样，这个调用无法保证会从 RAM 中删除被解锁的分页

# 确定内存驻留性

`mincore()` 系统调用是内存加锁系统调用的补充，它报告在一个虚拟地址范围中哪些分页当前驻留在 RAM 中，因此在访问这些分页时也不会导致分页故障

SUSv3 并没有规定 `mincore()`，很多 UNIX 实现都提供了这个函数，但不是所有的 UNIX 实现都提供了这个函数。

```
#define _BSD_SOURCE

#include <unistd.h>
#include <sys/mman.h>

int mincore(void *addr, size_t length, unsigned char *vec);
```

- `mincore()` 返回起始地址为 `addr` 长度为 `length` 字节的虚拟地址访问中分页的内存驻留信息。`addr` 中的地址必须是分页对齐的，并且由于返回的信息是有关整个分页的，因此 `length` 实际上会被向上舍入到系统分页大小的下一个整数倍
- 内存驻留相关的信息会通过 `vec` 返回，它是一个数组，其大小为 `(length + PAGE_SIZE – 1) / PAGE_SIZE` 字节。每个字节的最低有效位在相应分页驻留在内存中时会被设置，而其他位的设置在一些 UNIX 实现上是未定义的，因此可移植的应用程序应该只测试最低有效位
- `mincore()` 返回的信息在执行调用的时刻与检查 `vec` 中的元素的时刻期间可能会发生变化。唯一能够确保保持驻留在内存中的分页是那些通过 `mlock()` 或 `mlockall()` 锁住的分页

# 建议后续内存使用模式

