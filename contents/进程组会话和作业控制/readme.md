# 概述

**进程组**

- 进程组由一个或多个共享同一进程标识符 PGID 的进程组成，进程组 ID 的类型是 `pid_t`
- 一个进程组拥有一个进程组的首进程， 该进程是创建该组的进程，其进程 ID 为该进程组 ID
- 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻
- 一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组，进程组首进程无需是最后一个离开进程组的成员。

**会话**

- 会话是一组进程组的集合，进程的会话成员关系是由其会话标识符 SID 确定的，会话标识符也是 `pid_t` 类型
- 会话首进程是创建该会话的进程，其进程 ID 会成为会话 ID，新进程会继承其父进程的会话 ID

**终端**

- 一个会话中的所有进程共享单个控制终端，控制终端会在会话首进程首次打开一个终端设备时被建立
- 一个终端最多可能成为一个会话的控制终端
- 在窗口环境中，控制终端是一个伪终端，每个终端窗口都有一个独立的会话，窗口的启动 shell 是会话首进程和终端的控制进程

**前台进程组和后台进程组**

- 在任一时刻，会话中的一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组
- 只有前台进程组中的进程才能从控制终端中读取输入，当用户在控制终端中输入一个信号(例如：Control+C，Control+\，Control+Z)生成终端字符后，该信号会被发送到前台进程组中的所有成员

**控制进程**

- 当到控制终端的连接起来之后，会话首进程会成为该终端的控制进程
- 成为控制进程的主要标志是当断开与终端之间的连接时内核会向该进程发送一个 `SIGHUP` 信号

会话和进程组的主要用途是用于 shell 作业控制，对于交互式登录来讲，控制终端是用户登录的途径，登录 shell 是会话首进程和终端的控制进程，也是其自身进程组的唯一成员。从 shell 中发出的每个命令或通过管道连接的一组命令都会导致一个或多个进程的创建，并且 shell 会将这些进程放在一个新的进程组中，当命令或以管道连接的一组命令以 `&`  符号结束时会在后台进程组中运行这些命令，否则就会在前台进程组中运行这些命令。

```
echo $$		# 查看当前 shell 的 PID
400
find /2 > /dev/null | wc -l & # 运行两个后台进程
659
sort < longlist | uniq -c	# 运行两个前台进程
```

![](./img/process_grops_sessions_terminal.png)

# 进程组

每个进程都拥有一个以数字表示的进程组 ID，表示该进程所属的进程组，新进程会继承其父进程的进程组 ID。

```
#include <unistd.h>

pid_t getpgrp(void); 
```

- `getpgrp()` 返回一个进程的进程组 ID
- 如果 `getpgrp()` 的返回值与调用进程的进程 ID 匹配的话就说明该调用进程是其进程组的首进程

```
#include <unistd.h>

pid_t setpgid(pid_t pid,pid_t pgid); 
```

- `setpgid()` 将 `pid` 进程的进程组ID 修改为 `pgid`
- 如果将 `pid` 的值设置为 0，那么调用进程的进程组 ID就会被改变，如果将 `pgid` 的值设置为 0，那么 ID 为 `pid` 的进程的进程的进程组 ID 会被设置成 `pid` 的值，因此，下面的 `setpgid()` 调用是等价的：

```
setpgid(0,0);
setpgid(getpid(),0);
setpgid(getpid(),getpid());
```

- 如果 `pid` 和 `pgid` 参数指定了同一进程，即 `pgid`  是 0 或者与 ID 为 `pid` 的进程的进程 ID 匹配，那么就会创建一个新进程组，并且指定的进程会成为这个新组的首进程
- 如果两个参数的值不同，即 `pgid` 不是 0 或者与 ID 为 `pid`  的进程的进程 ID 不匹配，那么 `setpgid()` 调用会将一个进程从一个进程组中移到另一个进程组中
- 通常调用 `setpgid()` 函数的是 shell 和 `login`
- 在调用 `setpgid()` 时存在以下限制：
  - `pid` 参数可以仅指定调用进程或其中一个子进程，违反这条规则会导致 ESRCH 错误
  - 在组之间移动进程时，调用进程、由 `pid` 指定的进程以及目标进程组必须要属于同一个会话，违反这条规则见导致 EPERM 错误
  - `pid` 参数所指定的进程不能是会话首进程，违反这条规则将导致 EPERM 错误
  - 一个进程在其进程已经执行  `exec()` 后就无法修改该子进程的进程组 ID，违反这条规则会导致 EACCES 错误

## 在作业控制 shell 中使用 `setpgid()`

一个进程在其子进程已经执行 `exec()` 之后就无法修改该子进程的进程组 ID 的约束条件会影响到基于 shell 的作业控制程序设计，即需要满足下列条件：

- 一个任务(即一个命令或一组以管道符连接的命令)中的所有进程必须被放置在一个进程组中，这一步允许 shell 使用 `killpg()` 来同时向进程组中的所有成员发送作业控制信号，一般来讲，这一步需要在发送任意作业控制信号前完成
- 每个子进程在执行程序之前必须要被分配到进程组中，因为程序本身是不清楚如何操作进程组 ID 的

# 会话

会话是一组进程组集合，一个进程的会话成员关系是由其会话 ID 来定义的，会话 ID 是一个数字，新进程会继承其父进程的会话 ID。

```
#define _XOPEN_SOURCE 500
#include <unistd.h>

pid_t getsid(pid_t pid);
```

- `getsid()` 系统调用返回 `pid` 指定的进程的会话 ID
- 如果 `pid`  参数的值为 0，那么 `getsid()` 会返回调用进程的会话 ID

```
#include <unistd.h>

pid_t setsid(void);
```

- 如果调用进程不是进程组首进程，那么 `setsid()` 会创建一个新会话
- 创建步骤如下：
  - 调用进程成为新会话的首进程和该会话中新进程组的首进程，调用进程的进程组 ID 和会话 ID 会被设置成该进程的进程 ID
  - 调用进程没有控制终端，所有之前到控制终端的连接都会被断开
- 如果调用进程是一个进程组首进程，那么 `setsid()`  调用会报 `EPERM` 错误，这种约束是很有必要的，因为如果没有这个约束的话，进程组组织就能够将其自身迁移到另一个新的会话之中，而该进程组的其他成员则仍然位于原来的会话中，这将破坏会话和进程组之间严格的两级层次，因此一个进程组的所有成员必须属于同一个会话

# 控制终端和控制进程

一个会话中的所有进程可能会拥有一个单个控制终端，会话在被创建出来的时候是没有控制终端的，当会话首进程首次打开一个还没有成为某个会话的控制终端的终端时会建立控制终端，除非在调用 `open()` 时指定了 `O_NOCTTY` 标记。一个终端至多只能成为一个会话的控制终端。

控制终端会被 `fork()` 创建的子进程继承并且在 `exec()` 调用中得到保持。

当会话首进程打开了一个控制终端之后它同时也会成为该终端的控制进程，在发生终端断开之后，内核会向控制进程发送一个 `SIGHUP` 信号来通知这一事件额度发生。

如果一个进程拥有一个控制终端，那么打开 `/dev/tty` 就能够获取该终端的文件描述符。这对于一个程序在标准输入和输出被重定向之后需要确保自己确实在与控制终端进行通信是很有用的。如果进程没有控制终端，那么打开 `/dev/tty` 时将会报  `ENXIO` 的错误。

## 删除进程与控制终端之间的关联关系

使用 `ioctl(fd,TIOCNOTTY)`  操作能够删除进程与文件描述符 `fd`  指定的控制终端之间的关联关系。一旦调用之后再试图打开 `/dev/tty` 文件之后就会失败。

如果调用进程是终端的控制进程，那么在控制进程终止时：

- 会话中的所有进程将会失去与控制终端之间的关联关系
- 控制终端失去了与会话之间的关联关系，因此另一个会话首进程就能够获取该终端以成为控制进程
- 内核会向前台进程组的所有成员发送一个 `SIGHUP`  信号和一个 `SIGCONT` 信号来通知它们控制终端的丢失

##  在 BSD 上建立一个控制终端

在 BSD 系统上，在会话首进程中打开一个终端不会导致该终端成为控制终端，不管是否指定了 `O_NOCTTY` 标记，相反，会话首进程需要使用 `ioctl() TIOCSCTTY` 操作来显式地将文件描述符 `fd` 指定的终端建立为控制终端：

```
if(ioctl(fd,TIOCSCTTY) == -1)
	errExit("ioctl()");
```

只有在会话没有控制终端时才能执行这个操作。

## 获取表示控制终端的路径名

```
#include <stdio.h>

char *ctermid(char *ttyname);
```

- `ctermid()` 返回表示控制终端的路径名
- 可以通过函数结果和指定 `ttyname` 缓冲区来获取路径名，如果 `ttyname` 不是 `NULL`，那么它是一个大小至少为 `L_ctermid` 字节的缓冲区，路径名会被复制到这个数组中，如果 `ttyname` 是 `NULL`  将返回一个指向静态分配的缓冲区的指针，是不可重入的

# 前台和后台进程组

控制终端保留了前台进程组的概念，在一个会话中，在同一时刻只有一个进程能成为前台进程，会话中的其他所有进程都是后台进程组。前台进程组是唯一能够自由地读取和写入控制终端的进程组。当在控制终端中输入一个信号生成终端字符之后，终端驱动器会将相应的信号发送给前台进程组的成员。

```
#include <unistd.h>

pid_t tcgetpgrp(int fd);

int tcsetpgrp(int fd, pid_t pgid);
```

- `tcgetpgrp()` 获取一个终端的进程组，`tcsetpgrp()` 修改一个终端的进程组，这两个函数主要供任务控制 shell 使用
- `tcgetpgrp()` 中的参数 `fd` 指定的必须是调用进程的控制终端
- `tcsetpgrp()` 中的参数 `pgid` 必须与调用进程所属的会话中的一个进程的进程组 ID 匹配

































