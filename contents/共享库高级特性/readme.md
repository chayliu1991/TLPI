# 动态加载库

`dlopen API` 使得程序能够在运行时打开一个共享库，根据名字在库中搜索一个函数，然后调用这个函数，称为动态加载库，要在 Linux 上使用 `dlopen API`  构建程序，必须指定 `-ldl` 选项以便与 `libdl` 库链接起来。

## 打开共享库

```
#include <dlfcn.h>

void *dlopen(const char *filename, int flags);
```

- `filename` 中如果包含了 `/`，那么 `dlopen()` 会将其解释成一个绝对或者相对路径名，否则动态链接器将会使用之前的规则搜索共享库

- 成功时返回一个句柄，在后续对 `dlopen API` 中的函数调用可以使用该句柄来引用库，如果发生了错误(例如，无法找到库)，那么 `dlopen()` 返回 `NULL`

- 如果 `filename` 指定的共享库依赖于其他共享库，`dlopen()` 会自动加载这些库，并递归进行，形成这个库的依赖树

- 多次调用  `dlopen()` 将返回同一句柄，但是引用计数会增加，每次调用 `dclose()` 都会减小引用计数，只有当引用计数为 0 时，`dclose()` 才会从内存中删除这个库

- 将 `filename` 设置为 `NULL` 时，`dlopen()` 会返回主程序的句柄，后续对 `dlsym()` 的调用中使用这个句柄会使得：

  - 首先在主程序中搜索符号
  - 然后再程序启动时加载的共享库中进行搜索
  - 最后在所有使用了 `RTLD_GLOBAL` 标记的动态加载库中搜索

- `flags` 是一个位掩码：

  - `FTLD_LAZY` ：只有当代码被执行时才解析库中未定义的函数符号，如果某个特定符号的代码没有被执行到，那么将永远不会解析该符号，延迟解析只适用于函数引用，对变量的引用会被立即解析
  - `RTLD_NOW` ：在 `dlopen()` 结束之前立即加载库中所有未定义的符号，不管是否需要用到这些符号，这种做法的结果是打开库变得更慢，但能够立即检测到潜在的未定义函数符号错误
  - 设置环境变量 `LD_BIND_NOW` 为一个非空字符串能够强制动态链接器在加载可执行文件的动态依赖列表中的共享库时立即解析所有符号，类似 `RTLD_NOW`，并且会覆盖 `RTLD_LAZY` 标记的效果
  - `RTLD_GLOBAL` ： 这个库及其依赖树中的符号在解析由这个进程加载的其他库中的引用和通过 `dlsym()` 查找时可用
  - `RTLLD_LOCAL` ：与 `RTLD_GLOBAL`  相反，如果不指定任何常量，那么就取得这个默认值，它规定在解析后续加载的库中的引用时，这个库及其依赖树中的符号不可用
  - `RTLD_NODELETE` ：`dlclose()`  调用不要卸载库，即使其引用计数变为 0，这意味着在后面重新通过 `dlopen()`  加载库时不会重新初始化库中的静态变量，`gcc -Wl,-znodelete` 选项能够达到类似效果
  - `RTLD_NOLOAD` ：不加载库：
    - 使用这个标记来检查某个特定的库是否已经加载到了进程的地址空间中，如果已经加载了，那么 `dlopen()` 返回库的句柄，如果没有，返回 `NULL`
    - 使用这个标记来提升已加载库的标记，如在堆对之前使用 `RTLD_LOCAL` 打开的库调用 `dlopen()` 可以在 `flags` 参数中指定 `RTLD_NOLOAD | RTLD_GLOBAL`
  - `RTLD_DEEPBIND` ：在解析这个库中的符号引用时先搜索库中的定义，然后再搜索已加载的库中的定义，使得一个库能够实现自包含，即优先使用自己的符号定义，而不是在已加载的其他库中定义的全局符号，`-Bsymbolic` 链接器选项能够具有类似效果

  

  

 



