# 线程栈

创建线程时，每个线程都有一个属于自己的线程栈，且大小固定。在 Linux/x86-32 架构上，除主线程以外的所有现场，其栈缺省大小为 2MB。

在通过线程属性对象创建线程时，调用函数 `pthread_attr_setstacksize()` 所设置的属性决定了线程栈额度大小。

使用 `pthread_attr_setstack()` 可以同时控制线程栈的大小和位置，不过设置栈的地址将降低程序的可移植性。

更大的线程栈可以容纳大型的自动变量或者深度的嵌套函数调用，这也是改变线程栈大小的主要原因之一。

特定的架构系统上，可采用的线程栈大小最小值可以通过 `sysconf(_SC_THREAD_STACK_MION)` 来确定。

# 线程和信号

信号与线程模型之间存在一些明显的冲突：针对单线程进程要保持传统信号语义，与此同时，又需要开发出适用于多线程进程环境的新信号模型。

信号与线程模型之间的差异意味着将二者结合使用，将会非常复杂，应尽可能的避免。

尽管如此，有时候却必须在多线程程序中处理信号问题。

## UNIX 信号模型如何映射到线程中

信号动作属于进程层面，如果某进程的任一线程收到任何未经特殊处理的信号，且其缺省动作为 `stop` 或者 `terminate`，那么将停止或者终止该进程的所有线程。

对信号的处置属于进程层面，进程中的所有线程共享对每个信号的处置设置，如果某一线程使用函数 `sigaction()` 为某类信号创建了处理函数，那么当收到信号时，任何线程都会去调用处理函数。与之类似，如果将对信号的处置设置为忽略，那么所有线程都将忽略该信号。

信号的发送即可以针对整个进程，也可以针对某个特定线程，满足下列三者之一的信号属于面向线程：

- 信号的产生源于线程上下文中对特定硬件指令的执行，通常是：`SIGBUS`，`SIGFPE`，`SIGILL`，`SIGSEGV`
- 当线程视图对已断开的管道进行写操作时所产生的 `SIGPIPE` 信号
- 由函数 `pthread_kill()` 或 `pthread_sigqueue()` 所发出的信号，这些函数允许线程向同一进程下的其他线程发送信号

当多线程程序收到一个信号，且该进程已然为此信号创建了信号处理程序时，内核会任选一条线程来接收这一信号，并在该线程中调用信号处理程序对其进行处理。

信号掩码是针对每个线程而言，对于多线程程序而言，并不存在一个作用于整个进程范围的信号掩码，可以管理所有线程。`pthread_sigmask()` 可以设置各个线程独立的阻止或放行各种信号，通过操作每个线程的信号掩码，应用程序可以控制哪些线程可以处理进程收到的信号。

针对为整个进程所挂起的信号，以及为每条线程所挂起的信号，内核都分别维护有记录，调用函数会返回为整个进程和当前线程所挂起信号的并集，在新创建的线程中，每个线程的挂起信号集合初始时为空，可将一个针对线程的信号仅向目标线程投送，如果该信号遭到线程阻塞，那么它会一直保持挂起，直至线程将其放行，或者线程终止。

如果信号处理程序中断了对 `pthread_mutex_lock()` 的调用，那么该调用总是会自动重新开始，如果一个信号处理函数中断了 `pthread_cond_wait()` 的调用，那么该调用要么自动重新开始，要么返回 0，表示遭遇了假唤醒。

备选信号栈是每个线程特有的，新创建的线程并不从创建者处继承备选信号栈。

## 操作线程信号掩码

刚创建的新线程会从其创建者处继承信号掩码的一份拷贝，线程可以使用 `pthread_sigmask()` 来修改或者获取当前的信号掩码。

```
#include <signal.h>

int pthread_sigmask(int how,const sigset_t* set,sigset_t* oldset);
```

- 除了所操作的是线程信号掩码之外，`pthread_sigmask(0)` 与 `sigprocmask(0)` 的用法完全相同。

## 向线程发送信号

```
#include <signal.h>

int pthread_kill(pthread_t thread,int sig);
```

- `pthread_kill()` 可以向同一进程的另一个线程发送信号 `sig`，目标线程由 `thread`  标识

```
#define _SNU_SOURCE

#include <signal.h>

int pthread_sigqueue(pthread_t thread,int sig,const union sigval value);
```

- `sig` 标识要发送的信号，`thread` 标识目标线程， `value` 则指定了伴随信号的数据

## 妥善处理异步信号

没有任何 Pthreads API 属于异步信号安全函数，均无法在信号处理函数中安全加以调用。因为这些原因，所以当多线程应用程序必须处理异步产生的信号时，通常不应该将信号处理函数作为接收信号到达的通知机制，推荐方法如下：

- 所有线程都阻塞进程可能接收的所有异步信号，最简单的方法是，在创建任何其他线程之前，由主线程阻塞这些信号，后续创建的每个线程都会继承主线程信号掩码的一份拷贝
- 再创建一个专用线程，调用函数 `sigwaitinfo()`，`sigtimedwait()`，`sigwait()` 来接收收到的信号。当接收到信号时，专有线程可以安全地修改共享变量，并可调用并非异步信号安全的函数，也可以就条件变量发出信号，并采用其他线程或进程的通讯以及同步机制

```
#include <signal.h>

int sigwait(const sigset_t *set,int* sig);
```

除了以下不同的以外，`sigwawit()` 的操作与 `sigwaitinfo()` 相同：

- `sigwait()` 只返回信号编号，而非返回一个描述信号信息的 `siginfo_t` 类型
- 返回值与其他线程相关函数保持一致

如果有多个线程在调用 `sigwait()` 等待同一信号，那么当信号到达时只有一个线程会实际接收到，也无法确定收到信号的是哪条线程。

# 线程和进程控制

## 线程和 `exec()`

只要有任一线程调用了 `exec()` 系列函数之一时，调用程序将被完全替换，除了调用 `exec()` 的线程之外，其他所有线程都将立即消失。没有任何线程会针对线程特有数据执行解构函数，也不会调用清理函数，该进程的所有互斥量和属于进程的条件变量都会消失。

调用 `exec()` 之后，调用线程的线程 ID 是不确定的。

## 线程和 `fork()`

当多线程进程调用 `fork()` 时，仅会将发起调用的线程复制到子进程中，子进程中该线程的线程 ID 与父进程中发起 `fork()`  调用线程的线程 ID 是一致的。其他线程均在子进程中消失，也不会为这些线程调用清理函数以及针对线程特有数据的解构函数，这将导致：

- 虽然只将发起调用的线程复制到子进程中，但全局变量的状态以及所有的 Pthreads 对象，如：互斥量，条件变量等都会在子进程中得以保留，这将导致很棘手的问题，例如：在调用 `fork()` 时，另一线程已然锁定了某一互斥量，且对某一数据结构的更新刚进行了一半，此时子进程中的该线程无法解锁这一互斥量，如果试图获取这一互斥量，线程将会遭受阻塞。此外，子进程中的全局数据结构拷贝可能也处于不一致状态
- 因为并未执行清理函数和针对线程特有数据的解构函数，多线程程序的 `fork()` 调用会导致子进程的内存泄漏。另外，子进程中的线程很可能无法访问父进程中由其他线程所创建的线程特有数据项，因为子进程没有相应的应用指针

由于以上问题，推荐在多线程程序中使用 `fork()` 的唯一情况是：其后紧跟对 `exec()`的调用，因为新程序会覆盖原有内存，`exec()` 将导致子进程的所有 Pthreads 对象消失。

对于那些必须执行 `fork()`，而其后又无 `exec()` 紧跟的程序来说，Pthreads API 提供了一种机制：可以利用 `pthread_atfork()` 来创建 `fork()` 处理函数，其格式为：

```
pthread_atfork(prepare_func,perent_func,child_func);
```

- 每次 `pthread_atfork()` 调用都会将 `prepare_func` 添加到一个函数列表中，在调用 `fork()` 创建新的子进程之前，会按照注册的反序自动执行该函数列表中的函数，与之类似会将 `perent_func` 和  `child_func` 添加到函数列表中，在 `fork()` 返回之前，将分别在父、子进程中按注册顺序自动运行

## 线程与 `exit()`

如果任何线程调用了 `exit()` 或者主线程执行了 `return`，那么所有线程都将消失，也不会执行线程特有数据的解构函数以及清理函数。

# 线程实现模型

## 多对一(M:1) 实现

M:1 线程实现，关乎线程创建、调度以及同步的所有细节全部由进程内用户空间的线程库来处理，对于进程中存在的多个线程，内核一无所知。

优点：

- 许多线程操作(线程的创建，终止，上下文切换，互斥量以及条件变量操作)速度都非常快， 因为无需切换到内核模式
- 因为无需内核支持，所以移植性更高

缺点：

- 当一线程发起系统调用时，如 `read()` ，控制将由用户空间的线程库转交给内核，这就意味着，如果 `read()` 调用阻塞，那么所有的线程都会被阻塞
- 内核无法调度进程中的这些线程，因为内核并不知晓进程中存在的这些线程，也就无法在多处理器平台上将各线程调度给不同的处理器，也不可能设置某线程的优先级

## 一对一(1:1) 实现

在 1:1 线程实现中，每个线程都映射到一个单独的 KSE。内核分别对每个线程做调度处理，线程同步操作通过内核级系统调用实现。

 1:1 实现在遭受阻塞的系统调用时，不会导致进程的所有线程被阻塞，在多处理器硬件平台上，内核还可以将进程中的多个线程调度到不同的 CPU 上。

不过因为需要切换到内核模式，所以对线程的相关操作就要慢一些。另外，每个线程分别维护一个 KSE 也需要开销，如果应用程序包含了大量线程，则可能对内核调度器造成严重负担，降低系统的整体性能。

Linuxthreads 和 NPTL 都采用 1:1 模型。

## 多对多(M:N) 实现

M:N 实现结合了 1:1 和 M:1 模型的优点，避免了二者的缺点。

M:N 模型中，每个进程都可以拥有多个与之相关的 KSE，并且也可以把多个线程映射到一个 KSE，这种设计允许将同一应用的线程调度到不同的 CPU 上执行，同时也解决了随线程数量放大而带来的性能问题。

M:N 模型的缺点就是相对复杂。

# Linux POSIX 线程的实现

针对 Pthreads API：Linux 有两种实现：

- LinuxThreads：这是最初 Linux线程实现，已经过时
- NPTL(Native POSIX Threads Library)：这是 Linux 线程的现代实现版本

NPTL 线程使用 `clone()` 创建并指定如下标志：

```
CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND |
CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID |
CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
```

# Pthread API 的高级特性

- 可以对线程设置实时调度策略以及优先级
- 进程共享互斥量和条件变量
- 高级线程同步原语：障碍(barrier)，读写锁(read-write lock)，自旋锁(spin lock)

























































