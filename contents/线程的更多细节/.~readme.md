# 线程栈

创建线程时，每个线程都有一个属于自己的线程栈，且大小固定。在 Linux/x86-32 架构上，除主线程以外的所有现场，其栈缺省大小为 2MB。

在通过线程属性对象创建线程时，调用函数 `pthread_attr_setstacksize()` 所设置的属性决定了线程栈额度大小。

使用 `pthread_attr_setstack()` 可以同时控制线程栈的大小和位置，不过设置栈的地址将降低程序的可移植性。

更大的线程栈可以容纳大型的自动变量或者深度的嵌套函数调用，这也是改变线程栈大小的主要原因之一。

特定的架构系统上，可采用的线程栈大小最小值可以通过 `sysconf(_SC_THREAD_STACK_MION)` 来确定。

# 线程和信号

信号与线程模型之间存在一些明显的冲突：针对单线程进程要保持传统信号语义，与此同时，又需要开发出适用于多线程进程环境的新信号模型。

信号与线程模型之间的差异意味着将二者结合使用，将会非常复杂，应尽可能的避免。

尽管如此，有时候却必须在多线程程序中处理信号问题。

## UNIX 信号模型如何映射到线程中

信号动作属于进程层面，如果某进程的任一线程收到任何未经特殊处理的信号，且其缺省动作为 `stop` 或者 `terminate`，那么将停止或者终止该进程的所有线程。

对信号的处置属于进程层面，进程中的所有线程共享对每个信号的处置设置，如果某一线程使用函数 `sigaction()` 为某类信号创建了处理函数，那么当收到信号时，任何线程都会去调用处理函数。与之类似，如果将对信号的处置设置为忽略，那么所有线程都将忽略该信号。

信号的发送即可以针对整个进程，也可以针对某个特定线程，满足下列三者之一的信号属于面向线程：

- 信号的产生源于线程上下文中对特定硬件指令的执行，通常是：`SIGBUS`，`SIGFPE`，`SIGILL`，`SIGSEGV`
- 当线程视图对已断开的管道进行写操作时所产生的 `SIGPIPE` 信号
- 由函数 `pthread_kill()` 或 `pthread_sigqueue()` 所发出的信号，这些函数允许线程向同一进程下的其他线程发送信号

当多线程程序收到一个信号，且该进程已然为此信号创建了信号处理程序时，内核会任选一条线程来接收这一信号，并在该线程中调用信号处理程序对其进行处理。

信号掩码是针对每个线程而言，对于多线程程序而言，并不存在一个作用于整个进程范围的信号掩码，可以管理所有线程。`pthread_sigmask()` 可以设置各个线程独立的阻止或放行各种信号，通过操作每个线程的信号掩码，应用程序可以控制哪些线程可以处理进程收到的信号。

针对为整个进程所挂起的信号，以及为每条线程所挂起的信号，内核都分别维护有记录，调用函数会返回为整个进程和当前线程所挂起信号的并集，在新创建的线程中，每个线程的挂起信号集合初始时为空，可将一个针对线程的信号仅向目标线程投送，如果该信号遭到线程阻塞，那么它会一直保持挂起，直至线程将其放行，或者线程终止。

如果信号处理程序中断了对 `pthread_mutex_lock()` 的调用，那么该调用总是会自动重新开始，如果一个信号处理函数中断了 `pthread_cond_wait()` 的调用，那么该调用要么自动重新开始，要么返回 0，表示遭遇了假唤醒。

备选信号栈是每个线程特有的，新创建的线程并不从创建者处继承备选信号栈。

## 操作线程信号掩码

刚创建的新线程会从其创建者处继承信号掩码的一份拷贝，线程可以使用 `pthread_sigmask()` 来修改或者获取当前的信号掩码。

```
#include <signal.h>

int pthread_sigmask(int how,const sigset_t* set,sigset_t* oldset);
```

- 除了所操作的是线程信号掩码之外，`pthread_sigmask(0)` 与 `sigprocmask(0)` 的用法完全相同。
- 

































