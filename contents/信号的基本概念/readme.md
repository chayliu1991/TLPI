# 概念和概述

信号是事件发生时对进程的通知机制，有时称为软件中断，信号与硬件中断类似之处是：打断了程序执行的正常流程，大多数情况下，无法预测信号到达的准确时间。

一个具有合适权限的进程可以向另一个进程发送信号，进程也可以给自身发送信号，但多数信号源于内核，内核为进程产生信号的各类事件：

- 硬件异常，例如：被除0，引用了无法访问的内存区域
- 用户键入能够产生信号的终端字符，例如：Control+c，Control+z
- 发生软件事件，例如：定时器到期，进程执行的 CPU 时间超限，子进程退出

针对每个信号都定义了唯一一个小整数，从1开始顺序展开，`<signal.h>`  以 `SIGXXXXX`  形式的符号命名。

信号分为两大类：

- 第一组用于内核向进程通知事件，构成所谓传统或者标准信号，Linux 中标准信号的范围 1~31
- 另一组由实时信号构成

信号由于某些事件产生，产生信号后，会于稍后被传递给某一进程，而进程也会采取某些措施来响应信号，在产生和到达之间，信号处于等待状态。

通常，一旦内核接下来要调度该进程运行，等待信号将马上送达，或者如果进程正在运行，则会立即传递信号。如果一段代码不想被信号打断，则可以将该信号添加到进程信号掩码中，从而阻塞信号到达，直到信号从掩码中移除，才会送达。

信号到达后，进程的默认行为：

- 忽略信号，内核将丢弃信号，该信号对进程没有任何影响
- 终止进程，有时指的是进程异常终止，而不是进程调用 `exit()` 发生的正常终止
- 产生核心转储文件，同时终止进程，核心转储文件包含对进程虚拟内存的镜像，可将其加载到调试器检查进程终止时的状态
- 停止进程，暂停进程的执行
- 恢复之前停止的进程

除了默认行为，程序也可以改变信号到达时的响应行为：

- 采取默认行为
- 忽略信号
- 执行信号处理器函数

注意，无法将信号处理设置为终止进程或者转储核心，除非这是信号的默认处置，效果最为近似的是为信号安装一个处理器程序，并于其中调用 `exit()` 或者 `abort()` ，`abort()` 为进程产生一个 `SIGABRT` 信号，该信号将引发转储核心文件并终止进程。

# 信号类型和默认行为

- `SIGABRT` ：进程调用 `abort()` ，系统向进程发送该信号，默认情况下，该信号会终止进程，并产生核心转储文件

- `SIGALARM` ：经过 `alarm()`  或者 `setitimer()` 设置的定时器到期时，内核将产生该信号

- `SIGBUS` ：产生该信号表示发生了某种内存访问错误

- `SIGCHILD`：父进程的某一子进程终止时，内核向父进程发送该信号，父进程的某一子进程收到信号而停止或者恢复时，也可能向父进程发送该信号

- `SIGCLD` ：与 `SIGCHILD` 信号同义

-  `SIGCONT`：将该信号发送给已停止的进程，进程将恢复运行，当接收信号的进程当前不处于停止状态时，默认情况下将忽略该信号

- `SIGEMT`：UNIX 系统通常用该信号来标识一个依赖于实现的硬件错误

- `SIGFPE` ：该信号因特定类型的算法错误而产生，比如：除以 0

- `SIGHUP` ：当终端断开(挂机)时，将发送该信号给终端控制进程

- `SIGILL`：试图执行非法，即格式不正确的机器语言指令，系统将向进程发送该信号

- `SIGINFO`：该信号与 `SIGPWR` 信号同义

- `SIGINT`：用户终端输入中断字符 `control+c` ，终端驱动程序将发送该信号给前台进程组，该信号的默认行为是终止进程

- `SIGIO`：利用 `fcntl()`  系统调用，可于特定类型(诸如终端和套接字)的打开文件描述符发生 IO 事件时产生该信号

- `SIGTOT`：该信号与 `SIGABRT` 信号同义

- `SIGKILL`：

- `SIGKILL`：

- `SIGKILL`：

- `SIGKILL`：

- `SIGKILL`：

  `SIGKILL`：



















