POSIX 消息队列与 System V 消息队列的相似之处在于数据的交换单位是整个消息，但它们之间存在一些显著的差异：

- POSIX 消息队列是引用计数的。只有当所有当前使用队列的进程都关闭了之后才会对队列进程标记以便删除
- 每个 System V 消息都有一个整数类型，并且通过 `msgrcv()` 可以以各种方式选择消息。而 POSIX 消息由一个管理的优先级，并且消息之间是严格按照优先级顺序排队(以及接收)的
- POSIX 消息队列提供了一个特性允许在队列中的一条消息可用时异步的通知进程
- POSIX 消息通知特性运行一个进程能够在一条消息进入空队列时异步通知信号或者线程的实例化来接受通知
- 在Linux上可以使用 `poll`、`select`、`epoll` 来监听 POSIX 消息队列。System V 消息没有这个特性

# 概述

POSIX 消息队列 API 的主要函数如下：

- `mq_open()` 函数创建一个新消息队列或打开一个既有队列，返回后续调用中会用到的消息队列描述符
- `mq_send()` 函数向队列写入一条消息
- `mq_receive()` 函数从队列中读取一条消息
- `mq_close()` 函数关闭进程之前打开的一个消息队列
- `mq_unlink()` 函数删除一个消息队列并当所有进程关闭该队列时对队列进程标记以便删除

此外，POSIX 消息队列 API 还具备一些特别的特性：

- 每个消息队列都有一组关联的特性，其中一些特性可以在使用 `mq_open()` 创建或者打开时进行设置。获取和修改队列特性的工作是由 `mq_getattr()` 和`mq_setaddr()` 来完成的
- `mq_notify()` 函数允许一个进程向一个队列注册时接收消息通知。在注册完之后，当一条消息可用时会通过发送一个信号或者在一个单独的线程中调用一个函数来通知进程

# 打开、关闭和断开链接消息队列

## 打开一个消息队列

```
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <mqueue.h>

mqd_t mq_open(const char *name, int oflag);
mqd_t mq_open(const char *name, int oflag, mode_t mode,struct mq_attr *attr);
```

- `mq_open()` 函数创建一个新消息队列或打开一个既有队列
- `name` 参数标识出了消息队列
- `oflag` 参数是一个位掩码，它控制着 `mq_open()` 操作的各个方面，取值如下：

![](./img/mq_open.png)

- `oflag` 参数的其中一个用途是，确定是打开一个既有队列还是创建和打开一个新队列，`oflag`  不包含 `O_CREAT` 时，那么将会打开一个既有队列，如果 `oflag`  中包含了 `O_CREAT` 并且给定的 `name` 不存在时将会创建一个新的空队列，如果`oflag`  同时包含了 `O_CREAT` 和 `O_EXCL`，并且给定的 `name` 对应的队列已经存在，那么 `mq_open()` 就会失败
- `mode` 参数是一个位掩码，它指定了施加于新消息队列之上的权限
- `attr` 参数是一个 `mq_attr` 结构，它指定了新消息队列的特性。如果 `attr` 为 `NULL`，那么将使用实现定义的默认特性创建队列

## `fork()`、`exec()` 以及进程终止对消息队列描述符的影响

在 `fork()` 中子进程会接受其父进程在消息队列描述符的副本，并且这些描述符会引用同样的打开的消息队列描述。子进程不会继承父进程的任何消息通知注册。

当一个进程执行了一个 `exec()` 或终止时，所有其打开的消息队列描述符会被关闭。关闭消息队列描述符的结果是进程在相应队列上的消息通知注册会被注销。

 ## 关闭一个消息队列

```
#include <mqueue.h>

int mq_close(mqd_t mqdes);
```

- `mq_close()` 函数关闭了消息队列描述符 `mqdes`

如果调用进程已经通过 `mqdes` 在队列上注册了消息通知，那么通知注册会自动被删除，并且另一个进程可以随后向该队列注册消息通知。

当进程终止或者调用 `exec()` 时，消息队列描述符会被自动关闭。问问价描述符一样，应用程序应该在不再使用消息队列描述符的时候显示的关闭消息队列描述符以防止进程耗尽消息队列描述符的情况。

与文件上的 `close()` 一样，关闭一个消息队列并不会删除该队列。要删除队列必须显示的调用 `mq_unlink()`，它是 `unlink()` 在消息队列上的版本。

## 删除一个消息队列

`mq_unlink()` 函数删除通过 `name` 标识的消息队列，并将队列标记为在所有进程使用完该队列之后销毁该队列。

```
#include <mqueue.h>

int mq_unlink(const char *name);
```

# 描述符和消息队列之间的关系

消息队列是一个进程级别的句柄，它引用了系统层面的打开的消息队列描述符中的一个条目，而该条目引用了一个消息队列对象，如下图：

![](./img/mq_kernel.png)

- 一个打开的消息队列描述拥有一组关联的标记。SUSv3 只规定了一种这样的标记，即 `NONBLOCK`，它确定了 IO 是否是非阻塞的
- 两个进程能够持有引用同一个打开的消息队列描述的消息队列描述符。当一个进程在打开了一个消息队列之后调用 `fork()` 时就会发生这样的情况。这些描述符会共享 `O_NONBLOCK` 标记的状态
- 两个进程能够持有引用不同消息队列描述(它们引用了同一个消息队列)的打开的消息队列描述（如进程 A 中的描述符 z 和进程 B 中的描述符 y 都引用了/mq-r）。当两个进程分别使用 `mq_open()` 打开同一个队列时就会发生这种情况

# 消息队列特性

`mq_open()`、`mq_getattr()` 以及 `mq_setattr()` 函数都会接收一个参数，它是一个指向 `mq_attr` 结构的指针。这个结构是在 `<mqueue.h>` 中进行定义的，其形式如下：

```
struct mq_attr
{
    long mq_flags;	/* Message queue flags.  */
    long mq_maxmsg;	/* Maximum number of messages.  */
    long mq_msgsize;	/* Maximum message size.  */
    long mq_curmsgs;	/* Number of messages currently queued.  */
};
```









