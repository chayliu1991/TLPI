# 文件 IO 的内核缓冲：缓冲区高速缓存

系统操作与磁盘操作并不同步：`read()` 和 `write()` 系统调用在操作磁盘文件时不会直接发起磁盘访问，而是在用户空间缓冲区与内核缓冲区高速缓存之间复制数据。

- 对于输出，`write` 将数据送入内核空间的高速缓存区就立即返回，后续的某个时刻，内核将其缓冲区中的数据写入磁盘，在此期间如果另一个进程想要读取该文件几个字节，那么内核将自动从缓冲区高速缓存中提供这些数据。
- 对于输入，内核从磁盘中读取数据并存储到内核缓冲区中，`read()` 调用将从该缓冲区中读取数据，直到将缓冲区中的数据读完，内核将文件的下一段内容读到缓冲区高速缓存。

linux 内核对于缓冲区高速缓存的大小没有固定上限，内核会尽可能多的分配缓冲区高速缓存页，但受限于两个因素：

- 可用的物理内存总量
- 其他目的对物理内存的需求(例如：正在运行进程的文本段和数据段占据的物理内存)

内存不足时，内核会将缓冲区高速缓存的内容刷新到磁盘，并释放其供系统重用。

从内核 2.4 开始，不再单独维护一个缓冲区高速缓存，而是将文件 IO 缓冲区置于页面高速缓存中，其中还有诸如内存映射文件的页面。

## 缓冲区大小对 IO 系统调用性能的影响

采用大块空间缓冲数据，以执行更少的系统调用，可以极大地提高 IO 性能。

# stdio 库的缓冲

## 设置 stdio 流的缓冲模式

```
#include <stdio.h>

int setvbuf(FILE* stream,char* buf,int mode,size_t size);
```



























