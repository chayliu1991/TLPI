# 设计信号处理器函数

一般信号处理器函数设计得越简单越好，一个重要的原因就在于：这将降低引发竞争条件的风险，下面是针对信号处理器函数的两种常见设计：

- 信号处理器函数设置全局性标志变量并退出，主程序对此标志进行周期性检查，一旦置位随即采取相应动作
- 信号处理器函数执行某种类型的清理动作，接着终止进程或者使用非本地跳转将栈解开并将控制返回到主程序中的预订位置

## 再论信号的非队列化处理

在执行某信号的处理器函数时会阻塞同类信号的传递(除非在调用 `sigaction()` 时指定了 `SA_NODEFER` 标志)。

如果在执行处理器函数时，再次产生同类信号，那么会将该信号标记为等待状态，并在处理函数返回之后再进行传递。

在处理器函数执行期间，如果多次产生同类信号，那么仍然会将其标记为等待状态，但稍后只会传递一次。

因此需要注意：

- 无法对信号产生的次数进行可靠计数
- 在位信号处理器函数编码时可能需要考虑处理同类信号多次产生的情况

## 可重入函数和异步信号安全函数

### 可重入和非可重入函数

如果同一进程的多条线程都可以同时安全地调用某一函数，那么该函数就是可重入的，这里的安全指的是，无论其他线程调用该函数的执行状态如何，函数均可以产生预期结果。

更新全局变量或者静态数据结构的函数，一般是不可重入的。

### 标准的异步信号安全函数

异步信号安全的函数是指当从信号处理器函数调用时，可以保证其实现是安全的。

如果一个函数是可重入的，又或者信号处理器函数无法将其中断，就成该函数是异步信号安全的。

异步信号安全的函数：

![](./img/async_signal_safe_func.png)

信号处理器函数的选择：

- 确保信号处理器函数代码本身是可重入的，其只调用异步信号安全的函数
- 当主程序执行不安全函数或是去操作信号处理器函数也可能更新的全局数据结构时，阻塞信号的传递

### 信号处理器函数内部对 errno 的使用

由于可能会更新 `errno`，有一种变通的方法：

```
void handler(int sig)
{
	int savedErrno;
	savedErrno = errno;
	
	//@ do sth
	
	errno = savedErrno;
}
```

## 全局变量和 `sig_atomic_t`  数据类型

有时需要主程序和信号处理函数之间共享全局变量，一种常见的设计是，信号处理器函数只做一件事情，设置全局标志，主程序则会周期性地检查这个标志，采取相应动作来响应信号传递，应该在声明变量时，使用 `volatile` 关键字，从而防止编译器将其优化到寄存器中，除此之外还应该保证原子性：

```
volatile sig_atomic_t flag; 
```

在使用 `sig_atomic_t` 变量时，唯一能做的就是在信号处理器中进行设置，在主程序中检查，`++` 和 `--`  操作，可能是非原子的，不在保障范围内。

`<stdint.h>` 中定义了 `SIG_ATOMIC_MIN`  和 `SIG_ATOMIC_MAX`，用于表示 `sig_atomic_t` 类型的取值范围。

# 终止信号处理器函数的其他方法

从信号处理器函数中终止的其他一些方法：

- 使用 `_exit()` 终止进程，处理器函数事先可以做一些清理工作，不要使用 `exit()` 来终止信号处理函数，因为它不属于安全函数，在该函数调用 `_exit()` 之前刷新 `stdio`  的缓冲区
- 使用 `kill()` 发送信号来杀掉进程，即信号的默认动作是终止进程
- 从信号处理器函数中执行非本地跳转
- 使用 `abort()` 函数终止进程，产生核心转储

## 在信号处理器函数中执行非本地跳转

```
#include <setjmp.h>

int sigsetjmp(sigjmp_buf env, int savesigs);
void siglongjmp(sigjmp_buf env, int val);
```

- `sigsetjmp()` 和 `longjmp()` 的操作与 `setjmp()` 和 `longjmp()` 类似，区别是，`env` 的类型不同，并且多出 `sigsetjmp()` 多出一个参数 `savesigs`：
  - 如果 `savesigs` 为非0值，那么会将调用 `sigsetjmp()` 时进程的当前信号掩码保存于 `env`  中，之后通过指定相同的 `env`  参数的 `siglongjmp()` 调用进行恢复
  - 如果 `savesigs` 为0值， 则不会保存和恢复进程的信号掩码
- `longjmp()` 和 `siglongjmp()` 都不是安全函数，因为在信号处理器中调用这些函数，在执行非本地跳转之后去调用任何非异步信号安全函数也需要冒着同样的风险，为了规避这一问题，借助 `sigprocmask()` 临时将信号阻塞起来

## 异常终止进程

```
#include <stdlib.h>

void abort(void);
```

- `abort()` 产生 `SIGABRT` 信号来终止调用进程并产生核心转储文件
- 无论阻塞或者忽略 `SIGABRT` 信号，`abort()` 调用均不受影响，同时规定，除非进程捕获 `SIGABRT` 信号后信号处理器函数尚未返回，否则 `abort()` 必须终止进程
- 终止时可确保发生：若进程在发出一次 `SIGABRT` 信号后仍未终止，则 `abort()`  会对 `SIGABRT`  信号的处置重置为 `SIGDFL`,并再度发出 `SIGABRT` 信号，从而确保将进程杀死
- `abort()` 如果成功终止了进程，那么还将刷新 `stdio` 流，并将其关闭

# 在备选栈中处理信号













