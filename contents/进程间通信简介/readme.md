# IPC 工具分类

Unix系统上各种通信和同步工具可以分为三类：

- 通信：这些工具关注进程间的数据交换
- 同步：这些进程关注进程和线程操作之间的同步
- 信号：虽然信号的主要作用不为此，但是在特定场景下仍然可以将它作为一种同步工具；另外，信号也可以通信：信号编码本身是一种形式的信息，并且可以在实时信号上上绑定数据（一个整数或指针）

![](./img/IPC.png)

# 通信工具

通信工具可以用来在进程间相互交换数据（这些工具还可以用来在同一个进程中不同线程之间交换数据，但很少需要这样做，因为线程之间可以通过共享全局变量来交换信息。）

可以将通信工具分成两类。

- 数据传输工具：
  - 为了进行通信，一个进程将数据写入到 IPC 工具中，另一个进程从中读取数据
  - 这些工具要求在用户内存和内核内存之间进行两次数据传输：
    - 一次传输是在写入的时候从用户内存到内核内存
    - 另一次传输时在读取的时候从内核内存到用户内存

![](./img/data_exchange.png)

- 共享内存：
  - 共享内存运行进程通过将数据放到由进程间共享的一块内存中以完成这些信息的交换(内核通过将每个进程中的页表条目指向同一个RAM分页来实现这一功能)
  - 一个进程可以通过将数据放到共享内存块中使得其他进程读取这些数据
  - 由于通信无需系统调用以及用户内存和内核内存之间的数据传输，因此共享内存的速度非常快

## 数据传输

可以进一步将数据传输工具分成下列类别。

- 字节流：
  - 通过管道、FIFO以及数据报 socket 交换的数据是一个无分隔符的字节流
  - 每个读取操作可能会从 IPC 工具中读取任意数量的字节，不管写者写入的块的大小是什么
  - 这个模型参考了传统的 UNIX "文件是一个字节序列" 模型
- 消息：
  - 通过 System V 消息队列、POSIX 消息队列以及数据报 socket 交换的数据是以分隔符分隔的消息
  - 每个读取操作读取由写者写入的一整条消息，无法只读取部分消息，而把剩余部分留在 IPC 工具中，也无法在一个读取操作中读取多条消息
- 伪终端：伪终端是一种在特殊情况下使用的通信工具

数据传输工具和共享内存之间的差别包括以下几个方面：

- 尽管一个数据传输工具可能会有多个读取者，但是读取操作是有破坏性的。读取操作会消耗数据，其他进程将无法获取所消耗的数据
- 读取者和写者进程之间的同步是原子的。如果一个读取者试图从一个当前不包含数据的数据传输工具中读取数据，那么默认情况下读取操作会一直阻塞直到一些进程向该进程写入了数据

## 共享内存

大多数现代Unix系统提供了三种形式的共享内存：System V 共享内存、POSIX 共享内存以及内存映射。

注意：

- 尽管共享内存的通信速度更快，但是速度上的优势是用来弥补需要对在共享内存上发生的操作进行同步的不足的。如当一个进程正在更新共享内存中的一个数据结构时，另一个进程就不应该试图读取这个数据结构。在共享内存中，信号量通常用来作为同步方法
- 放入共享内存中的数据对所有共享这块内存的进程可见

# 同步工具

用于协调进程的操作。通过同步可以防止进程执行诸如同时更新一块共享内存或同时更新文件的同一个数据块之类的操作。如果没有同步，那么这种同时更新的操作可能会导致应用程序产生错误的结果。

UNIX 系统提供了下列同步工具：

- 互斥量和条件变量：这些同步工具通常用于 POSIX 线程

- 信号量：

  - 一个信号量是一个由内核维护的整数。其值永远不会小于0
  - 一个进程可以增加或者减少一个信号量的值。如果一个进程试图将信号量值减少到0，那么内核会阻塞该操作直到信号量增长到允许执行该操作的程序(或者进程可以要求执行一个非阻塞操作，那么就不会发生阻塞，内核会让该操作立即返回并返回一个标示无法立即执行该操作的错误)
  - 信号量的含义是由应用程序来确定的。一个进程减小一个信号量（如从 1 到 0）是为了预约对某些共享资源的独占访问，在完成了资源的使用之后可以增加信号量来释放共享资源以供其他进程使用
  - 最常用的信号量是二值信号量，一个值只能是 0 或 1 的信号量，但处理一类共享资源拥有多个实例的应用程序需要使用最大值等于共享资源数的信号量
  - Linux 既提供了 System V 信号量，又提供了 POSIX 信号量，它们的功能是类似的

- 文件锁：

  - 文件锁是设计用来协调同一文件的多个进程的动作的一种同步方法。它也可以用来协调对其他共享资源的访问
  - 文件锁分为两类：读（共享）锁和写（互斥）锁。任意进程都可以持有同一文件（或一个文件的某段区域）的读锁，但当一个进程持有了一个文件（或文件区域）的写锁之后，其他进程将无法获取该文件（或文件区域）上的读锁和写锁
  - Linux 通过 `flock()` 和  `fcntl()` 系统调用来提供文件加锁工具。`flock()` 系统调用提供了一种简单的加锁机制，允许进程将一个共享或互斥锁加到整个文件上。由于功能有限，现在已经很少使用 `flock()` 这个加锁工具了。`fcntl()` 系统调用提供了记录加锁，允许进程在同一文件的不同区域上加上多个读锁和写锁

在执行进程间同步时通常需要根据功能需求来选择工具。当协调对文件的访问时文件记录加锁通常是最佳的选择，而对于协调对其他共享资源的访问来讲，信号量通常是更佳的选择。

Linux 通过 `eventfd()` 系统调用额外提供了一种非标准的同步机制。这个系统调用创建了一个 `eventfd` 对象，该对象拥有一个相关的由内核维护的 8 字节无符号整数，它返回一个指向该对象的文件描述符。向这个文件描述符中写入一个整数会把该整数加到对象值上。当对象值为 0 时对该文件描述符的 `read()` 操作将会被阻塞。如果对象的值非0，那么 `read()` 会返回该值并将对象值重置为0。此外，可以使用 `poll()`、`select()` 以及 `epoll()` 来测试对象值是否为非零，如果是非零的话就表示文件描述符可读。

# IPC 工具比较















































