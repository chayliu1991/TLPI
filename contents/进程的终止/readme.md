# 进程的终止 `_exit()` 和 `exit()`

通常进程终止的两种方式：

- 异常终止，如由一信号的接收而引发的，该信号的默认动作是终止当前进程
- 进程可以调用 `_exit()` 系统调用正常终止

 ```
 #include <unistd.h>
 
 void _exit(int status);
 ```

- `_exit()` 是系统调用
- `status` 表示进程的终止状态，0 表示进程功成身退，非 0 值则不同的应用程序有不同的解释，父进程可以调用 `wait()` 获取 `status`  ，只有低 8 位可以为父进程所用，SUSv3 规定两个常量：`EXIT_SUCCESS(0)` ，`EXIT_FAILURE(1)`
- `_exit()` 的程序总会成功终止，即 `_exit()` 从不返回

程序一般不直接调用 `_exit()`，而是使用库函数 `exit()`，它会在调用 `_exit()` 之前执行各种动作。

```
#include <stdlib.h>

void exit(int status);
```

`exit()` 会执行的动作：

- 调用退出处理程序，即通过 `atexit()` 和 `on_exit()` 注册的函数
- 刷新 `stdio`  流缓冲区
- 使用由  `status` 提供的值，执行 `_exit()` 系统调用

从 `main()` 中返回，`return n` 等同于执行 `exit(n)`，即调用 `main()` 的运行时函数会将 `main()` 返回值作为 `exit()` 的参数。执行未指定返回值的 `return`，或者是 `main()`  末尾无返回语句，同样会导致 `main()` 的调用者执行 `exit()` 函数：

- C98 程序的退出状态取自栈或者特定  CPU 寄存器中的随机值
- C99 则等同于 `exit(0)`

# 进程终止的细节

无论进程是否正常终止，都会发生如何动作：

- 关闭所有打开文件描述符，目录流，信息目录描述符以及字符集转换描述符
- 作为文件描述符关闭的后果之一，将释放该进程持有的任何文件锁
- 分离任何已连接的 System V 共享内存段，且对应于各段的 `shm_nattch` 计数器值将减1
- 进程为每个 System V 信号量所设置的 `semadj`  的值将会被加到信号量中
- 如果该进程是一个管理终端的管理进程，那么系统会向该终端前台进程组中的每个进程发送  `SIGHUP` 信号，接着终端会与会话脱离
- 将关闭进程打开的任何 POSIX 有名信号量，类似于调用 `sem_close()`
- 作为进程退出的后果之一，如果某进程组成为孤儿，且该组中存在的任何已停止，则组中所有进程都将收到 `SIGHUP`  信号， 随之为 `SIGCONT` 信号
- 移除该进程通过 `mlock()` 或 `mlockall()` 所建立的任何内存锁
- 取消该进程调用 `mmap()` 所创建的任何内存映射

# 退出处理程序

退出处理程序可以在进程生命周期的任意时间点注册，并在进程调用 `exit()` 正常退出时自动执行，如果程序直接调用 `_exit()` 或者因为信号异常终止，则不会调用退出处理程序。

退出处理程序一经注册，将无法取消。

## 注册退出处理程序

```
#include <stdlib.h>

int atexit(void (*function)(void));
```

-  `atexit()` 将 `func()`  添加到一个函数列表中
- `atexit()` 出错时，返回非 0 值，并不一定是  -1
- 可以使用 `atexit()` 注册多个退出处理函数，最终执行顺序与注册的先后顺序相反
- 为保障可移植性，应用程序应该避免在退出处理程序内部使用 `exit()`
- `syconf(_SC_ATEXIT_MAX)` 返回系统实现允许注册的退出处理函数的最大个数
- `fork()` 创建的子进程将继承父进程注册的所有退出处理函数，如果进程调用 `exec()` ，子进程中已经注册的退出处理函数将被清除

经由 `exexit()` 注册的退出处理程序会受到两种限制：

- 退出处理程序在执行时无法获知传递给 `exit()` 的状态
- 无法给退出处理函数指定参数

```
#define _BSD_SOURCE
#include <stdlib.h>

int on_exit(void (*function)(int , void *), void *arg);
```































