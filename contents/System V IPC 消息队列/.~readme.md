消息队列允许进程以消息的形式交换数据。尽管消息对象在某些方面与管道和 FIFO 类似，但是它们之间扔存在显著差别：

- 用来引用消息队列的句柄是一个由  `msgget()` 调用返回的标识符。这些标识符与 Unix 系统上的大多数其他形式的 IO 所使用的文件描述符是不同的
- 通过消息对象进行的通信是面向消息的，即读者接收到由写者写入的整条消息。读取一条消息的一部分而让剩余部分遗留在队列中或者一次读取多条消息都是不可能的。这一点和管道不同，管道提供的是一个无法进程区分的字节流(即使用管道时读者一次可以读取任意数量的字节数，而不管写者写入的数据块大小)
- 除了包含数据之外，每条消息还有一个用整数表示的类型。从消息对象中读取消息既可以按照先入先出的顺序，也可以根据类型来读取数据

# 创建或打开一个消息队列

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msgget(key_t key, int msgflg);
```

- `msgget()` 系统调用创建一个新消息队列或者取得一个既有队列的标识符
- `msgflg` 参数是一个指定施加于新消息队列之上的权限或检查一个既有队列的权限的位掩码。此外，在 `msgflg` 参数中还可以将下列标记中的零个或多个标记取 `OR(|)`以控制 `msgget()` 的操作：
  - `IPC_CREAT` ：如果没有与指定的 `key` 对应的消息队列，那么就创建一个新队列
  - `IPC_EXCL` ：如果同时还指定了 `IPC_CREAT` 并且与指定的 `key` 对应的队列已经存在，那么调用就会失败并返回 `EEXIST` 错误

- `msgget()` 系统调用首先会在所有既有消息队列中搜索与指定的键对应的队列。如果找到了一个匹配的队列，那么就会返回该对象的标识符（除非在 `msgflg` 中同时指定了 `IPC_CREAT` 和 `IPC_EXCL`，那样的话就返回一个错误）。如果没有找到匹配的队列并且在 `msgflg` 中指定了 `IPC_CREAT`，那么就会创建一个新队列并返回该队列的标识符

# 交换消息

`msgsnd()`和`msgrcv()`系统调用执行消息队列上的IO。这两个系统调用接收的参数：

- 第一个参数：消息队列的标识符
- 第二个参数：`msgp` 是一个自定义的结构的指针，该结构用于存放被发送或者接收的信息，常见形式：

```
struct mymsg{
	long mtype;
	char mtext[];
};
```







- msgsnd()系统调用向消息队列写入一条消息。

















'