# 在堆上分配内存

堆是长度可变的连续虚拟内存，始于进程未初始化数据段的末尾，将堆当前的内存边界称为 "program break"。

##  调整 program break

改变堆的大小，其实就像命令内核改变晋城的 program break 位置一样，最初，program break 的位置正好位于未初始化数据段末尾之后。

```
#include <unistd.h>

int brk(void *end_data_segment);

void *sbrk(intptr_t increment);
```

- `brk()` 会将 program break 设置为参数 end_data_segment  所指定的位置，由于虚拟内存以页为分配单位，end_data_segment 实际会四舍五入到下一个内存页的边界处：
  - 试图将 program break 设置为一个低于其初始值的位置时，有可能导致无法预知的行为
  - program break 可以设置的额精确上限取决于一系列的因素，包括进程中对数据段大小的资源限制，以及内存映射、共享内存段、共享库的位置
- `sbrk()` 将 program break 在原有地址上增加了从参数 `increment` 传入的大小，如果调用成功 `sbrk()` 返回前一个 program break 的地址，也就是说如果 program break 增加，那么返回值将是指向这块新分配内存起始位置的指针
  - `sbrk(0)` 将返回 program break 的当前位置，对其不做改变

在 program break 的位置提升之后，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配，内核会在进程首次视图访问这些虚拟内存地址时自动分配新的物理内存页。

## 在堆上分配内存

```
#include <stdlib.h>

void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);
```

- `malloc()`  在堆上分配 `size` 个字节大小的内存，并返回指向新分配内存起始位置处的指针，其分配的内存未经初始化
- `malloc` 返回的内存块采用了字节对齐方式，一般是基于 8 或者 16 字节边界来进行内存分配，从而能够高效地访问任何类型的 C 语言数据结构
- 如果无法分配内存，`malloc()`  将会返回  `NULL`，并设置 `errno`，虽然内存分配失败的可能性很小，但是还是应该对 `malloc()` 返回值进行检查

```
#include <stdlib.h>

void free(void *ptr);
```

- `free()` 函数释放 `ptr` 所指向的内存块
- 一般情况下，`free()` 并不降低 program break 的位置，而是将这块内存添加到空闲内存列表中，供后续的  `malloc()` 函数循环使用：
  - 被释放的内存块通常位于堆的中间，而非堆的顶部，因而降低 program break 是不可能的
  - 最大限度地减少了程序必须执行的  `sbrk()` 调用次数，从而降低系统开销
  - 大多数情况下，降低 program break 的位置不会对那些分配大量内存的程序有多少帮助，因为它们通常倾向于持有已分配内存或者是反复释放和重新分配内存
- 给 `free()`  传递一个 `NULL` 指针，那么函数将什么都不做
- 调用 `free()`  后对参数的  `ptr` 的任何使用，包括重新传递给 `free()` 将产生不可预知的结果

### 调用 `free()` 还是不调用 `free()`

进程终止时，其占用的所有内存都会返还给操作系统，这包括在堆内存中由 `malloc()` 函数包内一系列函数所分配的内存。

虽然依靠终止进程来自动释放内存对大多数程序来说是可接受的，但是基于以下原因，最好能够在程序中显式释放所有分配的内存：

- 显示调用  `free()` 能使程序在未来修改时，更具可读性和可维护性
- 如果使用 `malloc()` 调试库来查找内存泄漏，那么会将任何未经显式释放处理的内存报告为内存泄漏，这会使分析变得复杂

## `malloc()` 和 `free()` 的实现

` malloc()` 的实现很简单：

- 首先会扫描之前由 `free()`  所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存，采用的扫描策略可能有 first-fit 或者 best-fito
- 如果这一内存块的尺寸正好与要求相当，就把它直接返回给调用者，如果是一块比较大的内存，那么将对其进行分割，再将一块大小相当的内存返回给调用者的同时，把剩余的那块内存块保留在空闲列表中
- 如果在空闲列表中根本找不到足够大的空闲内存块，那么 `malloc()`  将调用 `sbrk()` 以分配更多的内存，为了减少对  `sbrk()` 的调用次数，`malloc()` 并未只是严格按所需的字节数来分配内存，而是以更大幅度(以虚拟内存页大小的整数倍) 来增加 program break，并将超出部分置于空闲内存列表

![](./img/malloc.png)

`malloc()`  分配内存时会多分配几个字节用来记录这块内存的大小整数值，这个整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后。

`free()`  的实现更为有趣：

- `free()` 将内存块置于空闲列表之上
- 归还的大小正是依据 `malloc()` 预留的整数值

当将内存块置于空闲内存列表(双向链表)时，`free()`  会使用内存块本身的空间来存放链表指针，将自身添加到列表中。

![](./img/free_mem.png)













