伪终端是一个虚拟设备，它提供了一个 IPC 通道。通道的一端是一个期望连接到终端设备的程序。通道的另一端也是一个程序，这个程序通过 IPC 通道来发送其输入并读取输出以此来驱动面向终端的程序。

# 整体概览

![](./img/pseudo_terminal.png)

通过网络通信，套接字提供了解决这个问题的驱动部分。但是，我们无法直接面向终端程序的标准输入，输出和错误信息连接到套接字上。这是因为面向终端程序期望连接的是一个终端，以此才能执行例如将终端置为非规范程序，将回显打开或关闭，以及设定终端前台进程组等操作。如果某个程序尝试在一个套接字上执行这样的操作，那么相关的系统调用将失败。

此外，面向终端的程序期望终端驱动程序对其输入和输出做特定类型的处理。举个例子，在规范模式下，当终端驱动程序在一行的开始处发现文件结尾(`Ctrl+D`),
  将导致下一次 `read()` 调用不会返回任何数据。

最后，面向终端的程序必须有一个控制终端。这样允许程序通过打开 `/dev/tty` 来获取一个控制终端的文件描述符，并且也使得产生针对该程序的作业控制和相关的信号成为可能。

## 伪终端主从设备

伪终端提供了网络连接和面向终端程序之间那缺失的一环。伪终端是一对互联的虚拟设备：主伪终端和从伪终端，有时被共称为伪终端对。伪终端对提供了一条
  IPC 通道，这有点像双向管道：两个进程能分别打开主端和从端，并通过伪终端双向传输数据。

关于伪终端，关键点在于从设备表现的像一个标准终端一样。所以施加于终端设备的操作同样也可以施加于伪终端从设备上。这里面有些操作对伪终端来说没有
什么意义(例如，设定终端的线速或者奇偶校验)，但这并无大碍，因为伪终端从设备会悄悄忽略它。

## 如何使用伪终端

![](./img/pty.png)

pty 是伪终端的常用缩写形式。面向终端的程序的标准输入，输出以及错误都连接到伪终端从设备上，它也是程序的控制终端。在伪终端的另一侧，驱动程序作为用户的代理，提供面向终端程序的输入并读取程序的输出。

通常驱动程序同时读取输入并将输出写入到另外一个 IO 通道中。它的行为像一个中继，在伪终端和另外一个程序间双向传递数据。为了实现这一点，驱动程序必须同时监控 2 个方向上的输入。这通常由 IO 多路复用来实现，也可以采用一对进程或线程在两个方向上传递数据。
一般情况下使用伪终端的应用进程会按照如下步骤来做：

- 驱动程序打开伪终端主设备
- 驱动程序调用 `fork()` 创建一个子进程。子进程执行如下操作：
  - 调用 `setsid()` 来启动一个新的会话，使该子进程称为会话的头领进程。该操作也使得子进程失去它的控制终端
  - 打开同伪终端主设备相对应的从设备。由于子进程是会话的头领进程，且没有控制终端，伪终端从设备就变成了子进程的控制终端
  - 调用 `dup()` 为从设备复制标准输入，输出，错误的文件描述符
  - 调用 `exec()` 启动要连接到伪终端从设备的面向终端程序

此时这两个程序就可以通过伪终端进行通信了。任何由驱动程序写到主设备的信息，都会在从设备这端作为面向终端程序的输入。任何由面向终端的程序写到从设备的信息，都可以在主设备由驱动程序读取。

伪终端也可以能够用来连接任意的进程对(即，不一定是父子进程)。所有要做的就是打开伪终端主设备的进程需要将相关联的从设备名称通知给另一个进程即可，可能是将名称写到一个文件上又或者是通过其他 IPC 机制来传递。

ssh 的例子：

![](./img/ssh.png)

在远端主机上，伪终端主设备的驱动程序 ssh 服务器(sshd)，连接到伪终端从设备的面向终端的程序是 登录 shell。ssh 服务器作为胶水，通过连接到 ssh 客户端
的套接字将伪终端连接起来。一旦所有登录方面的细节全部完成，ssh 服务器和客户端的主要用途就是在本地主机上的用户终端和远端主机的 shell 之间双向传递字符。

## 伪终端的应用

除了网络服务之外，伪终端也在许多其他应用中得到了利用：

- `expect` 程序使用伪终端来允许交互式面向终端程序可以从脚本文件中驱动
- 类似 `xterm` 这样的终端模拟器利用伪终端来提供带有终端窗口的终端相关功能
- `screen`  程序使用伪终端在单个物理终端或者终端窗口同多个进程间实现多路复用
- `script` 程序使用到了伪终端，用来记录在 shell 会话中的所有输入和输出
- 当向文件或管道写输出时，有时候可以用伪终端来绕过由 stdio 实现的默认块缓冲机制，与之相对的是终端输出是行缓冲

# UNIX 98 伪终端

UNIX 98 伪终端使用的多个库函数：

- `posix_openpt()` 打开一个未使用的伪终端主设备，返回稍后会用到的代表该设备的文件描述符
- `grantpt()` 修改对应于伪终端主设备的从设备属主和权限
- `unlockpt()` 解锁对应于伪终端主设备的从设备，这样就能打开从设备了
- `ptsname()` 返回对应于伪终端主设备的从设备名称。之后从设备就可以通过 `open()` 来打开了

## 打开未使用的主设备

```
#define _XOPEN_SOURCE	500
#include <stdlib.h>
#include <fcntl.h>

int posix_openpt(int flags);
```

- `flags` 有 0 或以下多个常量组成：
  - `O_RDWR`：同时以可读和可写方式打开设备
  - `O_NOCTTY`：使终端不要成为进程的控制终端

UNIX 98 伪终端的数量限制：在 Linux 上 `/proc/sys/kernel/pty/max` 文件中定义了伪终端数量限制，默认值是 4096，可以设置为最大值 1048576。`/proc/sys/kernel/pty/nr` 文件中记录了当前系统中有多少 UNIX 98 伪终端正在使用。

## 修改从设备属主和权限

```
#define _XOPEN_SOURCE	500
#include <stdlib.h>

int grantpt(int fd);
```

- `grantpt()` 可以用来修改由文件描述符 `fd` 锁代表的伪终端主设备相关联的从设备的属主权限
- 可移植性良好的程序，应该在 `posix_openpt()` 调用 `grantpt()`

## 解除从设备

```
#define _XOPEN_SOURCE	500
#include <stdlib.h>

int unlockpt(int fd);
```

- `unlockpt()` 移除从设备的内部锁，该从设备同文件描述符 `fd` 所代表的伪终端主设备相关联
- 这个锁的机制目的是允许调用进程在其他进程能够打开这个伪终端从设备之前执行必要的初始化工作，比如 `grantpt()`
- 在调用  `unlockpt()` 之前尝试打开伪终端从设备将导致失败，错误码是 `EIO`

## 获取从设备名称

```
#define _XOPEN_SOURCE	500
#include <stdlib.h>

char *ptsname(int fd);
```

- `ptsname()` 返回伪终端从设备的名称，该从设备同文件描述符 `fd` 所代表的伪终端主设备相关联
- 在 Linux 上，`ptsname()` 返回形式为 `/dev/pts/nn` 的字符串，这里的 `nn` 由该伪终端从设备专有唯一标识号所取代
- 返回的从设备名称所占用的缓冲区通常是静态分配的，因此后续对 `ptsname()` 的调用将覆盖前次的结果

# 伪终端 IO

一对伪终端同一个双向管道很相似。任何写入到伪终端主设备的数据都会在从设备端作为输入出现。而任何写入到从设备端的数据也会在主设备作为输入出现。

伪终端对同双向管道之间的区别在于，伪终端的从设备端表现的像一个终端设备一样。从设备端解释输入的方式就和一个普通的控制终端解释键盘输入的方式一样。比如我们写入一个 `ctrl+C` 字符(通常代表中断字符)到伪终端主设备上，则从设备将其作为前台进程组产生一个 `SIGINT` 信号。如同一个常规的终端一样，当伪终端  从设备工作与规范模式下时，输入是按照行缓冲的。换句话说，只有当我们向伪终端主设备写入一个换行符时，向从设备端读取输入的程序才会看到一行输入。

同管道一样，伪终端的缓冲能力也是有限的。如果我们讲极限耗尽，那么未来的写操作会阻塞，知道伪终端另外一端的进程读取了一些字节后才能再次写入。在 Linux 上，伪终端的双向缓冲能力大约为 4kB。

如果关闭所有伪终端设备的文件描述符，则：

- 如果从设备有一个控制进程，会发送 `SIGHUP` 信号到那个进程
- 向从设备端读取的 `read()` 将返回文件结尾 `EOF`
- 写入到从设备端的 `write()` 操作会失败，错误码是 `EIO`

如果关闭所有代表伪终端从设备的文件描述符，则：

- 向主设备端读取的 `read()` 操作将会失败，错误码是 `EIO`
- 写入到主设备端的 `write()` 操作会失败，除非从设备的输入队列已满，这种情况下 `write()` 将会阻塞，如果随后重新打开从设备，这些写入的字节都可以被读取

## 信包模式

信包模式是当伪终端从设备上的软流空相关的事件发生时，自动通知给运行在伪终端主设备上进程的机制。这些事件包括：

- 刷新输入和输出队列
- 停止或开启终端输出
- 开启或关闭流控

信包模式能帮助处理提供网络登录服务的伪终端应用。
信包模式可以通过对代表伪终端主设备的文件描述符上执行 `TIOCPKT ioctl()` 来开启：

```
int arg;
arg = 1;
if(ioctl(mfd,TIOCPKT,&arg) == -1)
	errExit("ioctl() TIOCPKT");
```

当开启了信包模式后，从伪终端主设备读取要么返回一个非零控制符，这是一个比特掩码，表示从设备端的状态是否改变，要么返回零字节，紧跟着写入到从设备端的单个或多个字节数据。

当工作于信包模式的伪终端状态发生改变时，`select()` 会提示主设备端发生异常情况。

# 终端属性和窗口大小

伪终端从设备共享终端属性和窗口大小的结构，这表示运行在伪终端主设备上的程序可以通过在主设备文件描述符上调用 `tcsetattr()` 和 `ioctl()` 来修改从设备端的属性和窗口大小。







    























