System V 信号量不是用来在进程间传输数据的，而是用来同步进程的动作。信号量的一个常见用途是同步对一块共享内存的访问以防止出现一个进程在访问共享内存的同时另一个进程更新这块内存的情况。

一个信号量是一个由内核维护的整数，其值被限制为大于或者等于0。在一个信号量上可以执行各种操作(即系统调用)，包括：

- 将一个信号设置成一个绝对值
- 在信号量当前值的基础上加上一个数量
- 在信号量当前值的基础上减去一个数量
- 等待信号量的值等于 0

上面操作中的后两个可能会导致调用进程阻塞。当减小一个信号量的值时，内核会将所有试图将信号量值降低到 0 之下的操作阻塞。类似的，如果信号量的当前值不为 0，那么等待信号量的值等于 0 的调用进程将会发生阻塞。不管是何种情况，调用进程会一直保持阻塞直到其他一些进程将信号量的值修改为一个允许这些操作继续向前的值，在那个时刻内核会唤醒被阻塞的进程。下图显示了使用一个信号量来同步两个交替将信号量的值在 0 和 1 之间切换的进程的动作：

![](./img/signal_sync.png)

# 概述

使用 System V 信号量的常规步骤如下：

- 使用 `semget()` 创建或者打开一个信号量集
- 使用 `semctl() SETVAL` 或 `SETALL` 操作初始化集合中的信号量(只有一个进程需要完成这个任务)
- 使用 `semop()` 操作信号量的值。使用信号量的进程通常会使用这些操作来标识一种共享资源的获取和释放
- 当所有进程都不再需要使用信号量集之后 `semctl() IPC_RMID` 操作删除这个集合(只有一个进程需要完成这个任务)

大多数操作系统都为应用程序提供了一些信号量原语。但 System V 信号量表现出了不同寻常的复杂性，因为它们的分配是以被称为信号量集的组为单位进行的。在使用 `semget()` 系统调用创建集合的时候需要指定集合中的信号量数量。虽然同一时刻通常只会操作一个信号量，但通过 `semop()` 系统调用可以原子的在同一个集合中的多个信号量之上执行一组操作。

# 创建或者打开一个信号量集

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semget(key_t key, int nsems, int semflg);
```

- `semget()` 系统调用创建一个新信号量集或者获取一个既有集合的标识符
- 如果 `semget()` 创建一个新信号集，那么 `nsems` 会指定集合中信号量的数量，并且其值必须大于 0，如果 `semget()` 是获取一个既有集的标识符，那么 `nsems` 必须小于等于集合的大小（否则会发生 `EINVAL` 错误）。无法修改一个既有集中的信号量数量
- `semflg` 是一个位掩码，它指定了施加于新信号量集之上的权限或需检查一个既有集合的权限。指定权限的方式与为文件指定权限的方式是一样的。此外，在 `semflg` 中可以通过对下列标记中的零个或多个取 `OR` 来控制 `semget()` 的操作：
  - `IPC_CREAT` ：如果不存在与指定的 `key` 相关联的信号量集，那么就创建一个新集合
  - `IPC_EXCL` ：如果同时指定了 `IPC_CREAT` 并且与指定的 `key` 关联的信号量集已经存在，那么返回 `EEXIST` 错误
- `semget()` 在成功时会返回新信号量集中既有信号量集的标识符。后续引用单个信号量的系统调用必须要同时指定信号量标识符和信号量在集合中的序号。一个集合中的信号量从0开始计数。









