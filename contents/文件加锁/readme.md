# 概述

应用程序的一个常见需求是从一个文件中读取一些数据，修改这些数据，然后将这些数据写回文件。但是当多个进程同时更新一个文件时问题就出现了。

例如，执行下面的序列：

- 从文件中读取序号
- 使用这个序号完成应用程序定义的任务
- 递增这个序号并将其写回文件

![](./img/multi_process_file.png)

在多个进程同时操作同一份文件的过程中，很容易导致文件中的数据混乱，需要锁操作来保证数据的完整性。

尽管可以使用（比如说）信号量来完成所需的同步，但通常文件锁更好一些，因为内核能够自动将锁与文件关联起来。

# 使用 `flock()` 给文件加锁

尽管 `fcntl()` 提供的功能涵盖了 `flock()` 的功能，但这里仍需要对其进行介绍，因为在一些应用程序中仍然使用 `flock()` 并且其在继承和锁释放方面的一些语义与 `fcntl` 不同。

```
#include <sys/file.h>

int flock(int fd, int operation);
```

- `flock()` 系统调用在整个文件上放置一个锁。待加锁的文件是通过传入 `fd` 的一个打开的文件描述符指定的。`flock()` 中 `operation` 参数的可取值如下：

![](./img/operation.png)

- 默认情况下，如果另一个进程已经持有了文件上的一个不兼容的锁，那么 `flock()` 会阻塞。如果需要防止出现这种情况，那么可以在 `operation` 参数中对这些值取 `OR(|)`。在这种情况下，如果另一个进程已经持有了文件上的一个不兼容的锁，那么 `flock()` 就不会阻塞，相反它会返回 −1 并将 `errno` 设置成 `EWOULDBLOCK`
- 任意数量的进程可以同时持有一个文件上的共享锁，但是在同一个时刻只有一个进程能够持有一个文件上的互斥锁(即互斥锁会拒绝其他进程的互斥和共享锁请求)。下表对 `flock()` 锁的兼容规则进行了总结。这里假设进程 A 首先放置了锁，表中给出了进程 B 是否能够放置一把锁：

![](./img/flock.png)

- 不管一个进程在文件上的访问模式是什么（读、写、或读写），它都可以在文件上放置一把共享锁或者互斥锁
- 通过再次调用 `flock()` 并在 `operation` 参数中指定恰当的值可以将既有共享锁转换成一个互斥锁锁（反之亦然）。将一个共享锁转换成一个互斥锁，在另一个进程持有了文件上的共享锁时会阻塞，除非同时指定了 `LOCL_NB` 标记
- 锁转换的过程不一定是原子的。在转换过程中首先会删除既有锁，然后创建一个新锁。在这两步之间另一个进程对一个不兼容锁的未决请求可能会满足。如果发生了这种情况，那么转换过程会被阻塞，或者在指定了 `LOCK_NB` 的情况下转换过程会失败并且进程丢失其原先持有的锁

## 锁继承与释放的语义

通过 `flock()` 调用并将 `operation` 参数指定为 `LOCK_UN` 可以释放一个文件锁。另外，锁会在相应的文件描述符被关闭之后自动被释放。但问题其实更加复杂，通过 `flock()` 获取的文件锁是与打开的文件描述而不是文件描述符会在文件本身相关联的，这意味着当一个文件描述符被复制是（通过 dup()、dup2()或一个 fcntl() F_DUPFD 操作），新文件描述符会引用同一个文件锁。比如，如果获取了fd所引用的文件上的一个锁，那么下面的代码就会释放这个锁

```
flock(fd, LOCK_EX);
newfd = dup(fd);
flock(fd, LOCK_UN);
```

如果已经通过一个特定的文件描述符获取了一个锁并创建了该文件描述符的一个或者多个副本，那么如果不显示的执行一个解锁操作，那么只有当所有描述符副本都被关闭之后所才会被释放。

如果使用 `open()` 获取第二个引用同一个文件的文件描述符，那么flock()就会将第二个文件描述符当成是一个不同的描述符。比如下面代码会在第二个 `flock()` 调用上阻塞：

```
fd1 = open("a.txt", O_RDWR);
fd2 = open("a.txt", O_RDWR);
flock(fd1, LOCK_EX);
flock(fd2, LOCK_EX); // 阻塞，因为fd1已经获取到了锁
```

当使用 `fork()` 创建一个子进程时，这些子进程会复制其父进程的文件描述符，并且与使用 `dup()` 调用之类的函数复制的描述符一样，这些描述符会引用同一个打开的文件描述，进而会引用同一个锁。比如，下面代码会导致子进程删除父进程的锁：

```
flock(fd, LOCK_EX);  // 父进程获取锁
if(fock() == 0){
	flock(fd, LOCK_UN); // release lock shared with parent
}
```

有时候可以利用这些语义来将一个文件锁从父进程（原子地）传输到子进程：在 `fork()` 之后，父进程关闭其文件描述符，然后锁就只在子进程的控制之下了。

通过 `flock()` 创建的锁在 `exec()` 中会得到保留（除非在文件描述符上设置了 `close-on-exec` 标记并且该文件描述符是最后一个引用底层的打开的文件描述的描述符）。







