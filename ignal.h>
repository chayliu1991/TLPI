SIGSUSPEND(2)                                                                                               Linux Programmer's Manual                                                                                               SIGSUSPEND(2)

NNAAMMEE
       sigsuspend, rt_sigsuspend - wait for a signal

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssiiggnnaall..hh>>

       iinntt ssiiggssuussppeenndd((ccoonnsstt ssiiggsseett__tt **_m_a_s_k));;

   Feature Test Macro Requirements for glibc (see ffeeaattuurree__tteesstt__mmaaccrrooss(7)):

       ssiiggssuussppeenndd(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE

DDEESSCCRRIIPPTTIIOONN
       ssiiggssuussppeenndd() temporarily replaces the signal mask of the calling process with the mask given by _m_a_s_k and then suspends the process until delivery of a signal whose action is to invoke a signal handler or to terminate a process.

       If  the  signal  terminates  the process, then ssiiggssuussppeenndd() does not return.  If the signal is caught, then ssiiggssuussppeenndd() returns after the signal handler returns, and the signal mask is restored to the state before the call to ssiiggssuuss‐‐
       ppeenndd().

       It is not possible to block SSIIGGKKIILLLL or SSIIGGSSTTOOPP; specifying these signals in _m_a_s_k, has no effect on the process's signal mask.

RREETTUURRNN VVAALLUUEE
       ssiiggssuussppeenndd() always returns -1, with _e_r_r_n_o set to indicate the error (normally, EEIINNTTRR).

EERRRROORRSS
       EEFFAAUULLTT _m_a_s_k points to memory which is not a valid part of the process address space.

       EEIINNTTRR  The call was interrupted by a signal.

CCOONNFFOORRMMIINNGG TTOO
       POSIX.1-2001, POSIX.1-2008.

NNOOTTEESS
       Normally, ssiiggssuussppeenndd() is used in conjunction with ssiiggpprrooccmmaasskk(2) in order to prevent delivery of a signal during the execution of a critical code section.  The caller first blocks the signals with ssiiggpprrooccmmaasskk(2).  When  the  critical
       code has completed, the caller then waits for the signals by calling ssiiggssuussppeenndd() with the signal mask that was returned by ssiiggpprrooccmmaasskk(2) (in the _o_l_d_s_e_t argument).

       See ssiiggsseettooppss(3) for details on manipulating signal sets.

   CC lliibbrraarryy//kkeerrnneell ddiiffffeerreenncceess
       The  original  Linux system call was named ssiiggssuussppeenndd().  However, with the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit _s_i_g_s_e_t___t type supported by that system call was no longer fit for purpose.  Consequently, a
       new system call, rrtt__ssiiggssuussppeenndd(), was added to support an enlarged _s_i_g_s_e_t___t type.  The new system call takes a second argument, _s_i_z_e___t _s_i_g_s_e_t_s_i_z_e, which specifies the size in bytes of the signal set in _m_a_s_k.   This  argument  is  cur‐
       rently required to have the value _s_i_z_e_o_f_(_s_i_g_s_e_t___t_) (or the error EEIINNVVAALL results).  The glibc ssiiggssuussppeenndd() wrapper function hides these details from us, transparently calling rrtt__ssiiggssuussppeenndd() when the kernel provides it.

SSEEEE AALLSSOO
       kkiillll(2), ppaauussee(2), ssiiggaaccttiioonn(2), ssiiggnnaall(2), ssiiggpprrooccmmaasskk(2), ssiiggwwaaiittiinnffoo(2), ssiiggsseettooppss(3), ssiiggwwaaiitt(3), ssiiggnnaall(7)

CCOOLLOOPPHHOONN
       This page is part of release 4.04 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about reporting bugs, and the latest version of this page, can be found at http://www.kernel.org/doc/man-pages/.

Linux                                                                                                               2015-07-23                                                                                                      SIGSUSPEND(2)
SIGWAITINFO(2)                                                                                              Linux Programmer's Manual                                                                                              SIGWAITINFO(2)

NNAAMMEE
       sigwaitinfo, sigtimedwait, rt_sigtimedwait - synchronously wait for queued signals

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssiiggnnaall..hh>>

       iinntt ssiiggwwaaiittiinnffoo((ccoonnsstt ssiiggsseett__tt **_s_e_t,, ssiiggiinnffoo__tt **_i_n_f_o));;

       iinntt ssiiggttiimmeeddwwaaiitt((ccoonnsstt ssiiggsseett__tt **_s_e_t,, ssiiggiinnffoo__tt **_i_n_f_o,,
                        ccoonnsstt ssttrruucctt ttiimmeessppeecc **_t_i_m_e_o_u_t));;

   Feature Test Macro Requirements for glibc (see ffeeaattuurree__tteesstt__mmaaccrrooss(7)):

       ssiiggwwaaiittiinnffoo(), ssiiggttiimmeeddwwaaiitt(): _POSIX_C_SOURCE >= 199309L

DDEESSCCRRIIPPTTIIOONN
       ssiiggwwaaiittiinnffoo() suspends execution of the calling thread until one of the signals in _s_e_t is pending (If one of the signals in _s_e_t is already pending for the calling thread, ssiiggwwaaiittiinnffoo() will return immediately.)

       ssiiggwwaaiittiinnffoo()  removes  the  signal  from the set of pending signals and returns the signal number as its function result.  If the _i_n_f_o argument is not NULL, then the buffer that it points to is used to return a structure of type _s_i_g_‐
       _i_n_f_o___t (see ssiiggaaccttiioonn(2)) containing information about the signal.

       If multiple signals in _s_e_t are pending for the caller, the signal that is retrieved by ssiiggwwaaiittiinnffoo() is determined according to the usual ordering rules; see ssiiggnnaall(7) for further details.

       ssiiggttiimmeeddwwaaiitt() operates in exactly the same way as ssiiggwwaaiittiinnffoo() except that it has an additional argument, _t_i_m_e_o_u_t, which specifies the interval for which the thread is suspended waiting for a signal.  (This interval will be  rounded
       up to the system clock granularity, and kernel scheduling delays mean that the interval may overrun by a small amount.)  This argument is of the following type:

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           }

       If  both  fields of this structure are specified as 0, a poll is performed: ssiiggttiimmeeddwwaaiitt() returns immediately, either with information about a signal that was pending for the caller, or with an error if none of the signals in _s_e_t was
       pending.

RREETTUURRNN VVAALLUUEE
       On success, both ssiiggwwaaiittiinnffoo() and ssiiggttiimmeeddwwaaiitt() return a signal number (i.e., a value greater than zero).  On failure both calls return -1, with _e_r_r_n_o set to indicate the error.

EERRRROORRSS
       EEAAGGAAIINN No signal in _s_e_t was became pending within the _t_i_m_e_o_u_t period specified to ssiiggttiimmeeddwwaaiitt().

       EEIINNTTRR  The wait was interrupted by a signal handler; see ssiiggnnaall(7).  (This handler was for a signal other than one of those in _s_e_t.)

       EEIINNVVAALL _t_i_m_e_o_u_t was invalid.

CCOONNFFOORRMMIINNGG TTOO
       POSIX.1-2001, POSIX.1-2008.

NNOOTTEESS
       In normal usage, the calling program blocks the signals in _s_e_t via a prior call to ssiiggpprrooccmmaasskk(2) (so that the default disposition for these signals does not occur if they become pending between successive calls  to  ssiiggwwaaiittiinnffoo()  or
       ssiiggttiimmeeddwwaaiitt()) and does not establish handlers for these signals.  In a multithreaded program, the signal should be blocked in all threads, in order to prevent the signal being treated according to its default disposition in a thread
       other than the one calling ssiiggwwaaiittiinnffoo() or ssiiggttiimmeeddwwaaiitt()).

       The set of signals that is pending for a given thread is the union of the set of signals that is pending specifically for that thread and the set of signals that is pending for the process as a whole (see ssiiggnnaall(7)).

       Attempts to wait for SSIIGGKKIILLLL and SSIIGGSSTTOOPP are silently ignored.

       If multiple threads of a process are blocked waiting for the same signal(s) in ssiiggwwaaiittiinnffoo() or ssiiggttiimmeeddwwaaiitt(), then exactly one of the threads will actually receive the signal if it becomes pending for the process as a  whole;  which
       of the threads receives the signal is indeterminate.

       POSIX leaves the meaning of a NULL value for the _t_i_m_e_o_u_t argument of ssiiggttiimmeeddwwaaiitt() unspecified, permitting the possibility that this has the same meaning as a call to ssiiggwwaaiittiinnffoo(), and indeed this is what is done on Linux.

   CC lliibbrraarryy//kkeerrnneell ddiiffffeerreenncceess
       On Linux, ssiiggwwaaiittiinnffoo() is a library function implemented on top of ssiiggttiimmeeddwwaaiitt().

       The glibc wrapper functions for ssiiggwwaaiittiinnffoo() and ssiiggttiimmeeddwwaaiitt() silently ignore attempts to wait for the two real-time signals that are used internally by the NPTL threading implementation.  See nnppttll(7) for details.

       The original Linux system call was named ssiiggttiimmeeddwwaaiitt().  However, with the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit _s_i_g_s_e_t___t type supported by that system call was no longer fit for purpose.  Consequently, a
       new system call, rrtt__ssiiggttiimmeeddwwaaiitt(), was added to support an enlarged _s_i_g_s_e_t___t type.  The new system call takes a fourth argument, _s_i_z_e___t _s_i_g_s_e_t_s_i_z_e, which specifies the size in bytes of the signal set in _s_e_t.  This  argument  is  cur‐
       rently required to have the value _s_i_z_e_o_f_(_s_i_g_s_e_t___t_) (or the error EEIINNVVAALL results).  The glibc ssiiggttiimmeeddwwaaiitt() wrapper function hides these details from us, transparently calling rrtt__ssiiggttiimmeeddwwaaiitt() when the kernel provides it.

SSEEEE AALLSSOO
       kkiillll(2), ssiiggaaccttiioonn(2), ssiiggnnaall(2), ssiiggnnaallffdd(2), ssiiggppeennddiinngg(2), ssiiggpprrooccmmaasskk(2), ssiiggqquueeuuee(3), ssiiggsseettooppss(3), ssiiggwwaaiitt(3), ssiiggnnaall(7), ttiimmee(7)

CCOOLLOOPPHHOONN
       This page is part of release 4.04 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about reporting bugs, and the latest version of this page, can be found at http://www.kernel.org/doc/man-pages/.

Linux                                                                                                               2015-07-23                                                                                                     SIGWAITINFO(2)
