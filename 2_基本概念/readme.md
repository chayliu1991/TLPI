# 内核

## 内核的职责

- 进程调度。linux 属于抢占式多任务操作系统：
  - 多任务：多个进程可以同时驻留内存，每个进程都可以获得 CPU 的使用权
  - 抢占：指的是一组规则，控制着进程如何使用 CPU
- 内存管理。linux 采用虚拟内存管理机制：
  - 进程与进程，进程与内核之间彼此隔离
  - 只需将进程的一部分保持在内存中
- 提供文件系统。
- 创建和终止进程。
- 对设备的访问。
- 联网。
- 提供系统调用接口。

## 内核态和用户态

CPU 至少在两种不同的状态下运行：内核态和用户态，与之对应的虚拟内存也划分为内核空间和用户空间。

- 用户态运行时只能访问用户空间的内存，访问内核空间的内存将会引发硬件异常。
- 内核态运行时可以访问内核空间的内存，也可以访问用户空间的内存。

内核态可以执行一些特定的操作，比如：执行 halt，访问内存管理硬件等。

## 以进程及内核视角检视系统

### 进程的视角

对于进程来说，很多事情都是无法预期的：

- 进程并不知道自己对 CPU 的使用何时到期，何时才能再次获得使用权。
- 信号的传递和进程间通信事件随时都可能发生，并不确定其准确时机。
- 进程不清楚自己在内存中的位置。
- 进程不清楚访问的文件在磁盘驱动器的何处，只是通过名称来引用文件。
- 进程间彼此不能直接通信。
- 进程本身无法创建新的进程，也不能自行了断。
- 进程不能与计算机外接的输入输出设备直接通信。

### 内核视角

内核对于系统的一切无所不知，无所不能：

- 决定哪个进程接掌  CPU 的使用，何时接掌何时到期。
- 内核中维护包含进程创建，状态变化，终结等信息，并会及时更新。
- 内核维护的数据结构可以将文件名转换为磁盘的物理位置。
- 内核维护进程虚拟内存及计算机物理内存以及磁盘交换区之间的映射关系。
- 进程间的所有通信都要通过内核提供的机制来完成。
- 根据进程的请求，内核会创建新的进程或者终止现有线程。
- 内核执行与输入输出设备之间的直接通信。

# shell

shell 又称为命令解释器，是一个特殊的用户进程，主要用于读取用户输入的命令、执行相应的程序并返回相应的结果。

几种重要的 shell：

- Bourne shell(sh)
- C shell(csh)
- Korn shell(ksh)
- Bourne again shell(bash)：对于 Bourne shell 的重新实现。

# 用户和组

## 用户

系统密码文件 `/etc/passwd`为每个用户都定义一行记录：

- 用户名
- 用户 ID(UID)
- 组 ID，用户所属第一个组
- 主目录，用户登录后居于的初始目录
- 登录 shell，执行以解释用户命令的程序名称

## 组

系统密码文件 `/etc/group` 为每个用户组都定义一行记录：

- 组名
- 组 ID(GID)
- 用户列表

## 超级用户

超级用户在系统中享有特权，ID 为 0，通常登录名为 root。

超级用户凌驾于系统的权限检查之上。

# 单根目录层级、目录、链接及文件

## 单根目录

内核维护着一套单根目录结构，以放置所有的文件。

根目录称为 `/`，所有的文件和目录都是根目录的子孙。

## 文件类型

- 普通文件
- 设备文件
- 管道
- 套接字
- 目录
- 符号链接

## 路径和链接

`文件名+引用` 的组合称为链接。每个文件都可以有多条链接，因而可以有多个不同的名称，在相同或者不同的目录中出现。

每个目录都至少包含两条记录：

- `.`：指向目录自身的链接。
- `..`：指向上一级目录的链接。

## 符号链接

在目录列表中，符号链接对应 `文件名+指针` 的一条记录，指针指向的是另一个文件名，称为符号链接的目标。系统调用路径名时，内核会自动解除符号链接的引用：

- 上述过程会递归调用，最大次数有限制。
- 如果符合链接指向的文件不存在，那么可将该链接视为空链接。

## 文件名

- 最大 255 个字符。
- 除了 `/` 和 `\0` 之外所有字符。

## 路径名

- 绝对路径名：以 `/` 开始，指明文件相对于根目录的位置
- 相对路径名：相对于进程当前工作目录的文件位置

## 当前目录

每一个进程都有一个当前工作目录，也是进程解释相对路径名的参照点。

进程的当前工作目录继承自其父进程。

## 文件的所有权和权限

每个文件都有一个属主和属组，系统根据文件的所有权来判定用户对于文件的访问权限。

为了访问文件，系统把用户分为3类：

- 文件的属主用户
- 文件的数组成员用户
- 其他用户

# 文件 I/O 模型

I/O 通用性：同一套系统调用(open(),read(),write(),close()) 所执行的 I/O 操作，可以施于所有的文件类型。

UNIX 系统没有文件结束符的概念，读取文件时如果没有数据返回时，便会认定抵达文件末尾。

## 文件描述符

使用文件描述符(非负整数)来指代打开的文件。

获取描述符可以使用 open()。

shell 启动的进程会继承3个已经打开的文件描述符：

- 0，标准输入
- 1，标准输出
- 2，标准错误

## stdio 函数库

C 语言执行 I/O 操作时，会调用 C 语言标准库的 I/O 函数。

- fopen()，fclose()
- scanf()，printf()
- fgets()，fputs()

stdio 函数位于 I/O 系统调用层(open(),read(),write(),close()) 之上。

# 程序

程序以两种面目视人：

- 源码
- 二进制

## 命令行参数

- argc：变量包含命令行参数的总个数
- grgv：指针数组，成员指针逐一指向每个命令行参数

# 进程

进程是正在执行的程序实例。

内核将程序代码、数据载入到虚拟内存，创建存储进程各种信息的数据结构。

从内核来看，进程是一个个实体，内核必须在它们之间共享各种计算机资源。

## 进程的内存布局

逻辑上将一个进程划分为几个段：

- 文本：程序的指令
- 数据：程序使用的静态变量
- 堆：程序从该区域动态分配额外的内存
- 栈：随函数调用，返回而增减的一片内存，为局部变量和函数调用链接信息分配存储空间

## 创建进程和执行程序

- 使用系统调用 `fork()`  来创建一个新的进程，调用 `fork()` 的进程称为父进程，新创建的进程称为子进程。
- 内核通过复制的方式来创建子进程，可以修改继承来的数据段、栈段以及堆段，并且与父进程共享只读的代码段。
- 子进程要么去执行与父进程共享的代码段中的部分函数，要么使用 `execve` 去加载一个全新的程序，它会销毁现有的代码段，数据段，栈段以及堆段，并根据新程序的内容来替换它们。

## 进程 ID 和 父进程 ID

每个进程都有一个唯一的整数标识 PID。

每个进程还有一个父进程 PPID 来标识创建自己的进程。

## 进程终止和终止状态

进程终止的两种方式：

- 调用 `_exit()` 系统调用或者 `exit()`等库函数，请求退出。
- 向进程传递信号，将其杀死。

无论进程以何种方式退出，都会生成终止状态(非负小整数)，可供父进程 `wait()` 调用检测到，终止状态：

- `_exit()` ： 调用时指明
- 杀死进程的信号

终止状态是0表示进程功成身退，非0则表示发送错误，大多数 shell 将前一个执行程序的终止状态保存在 `$?` 中。

## 进程的用户和组标识符

每个进程都有一组与之相关的用户 ID(UID) 和一个组 ID(GID)：

- 真实用户 ID 和 组 ID：表示进程所属的用户和组，新进程从父进程继承这些内容。
- 有效用户 ID 和 组 ID：一般情况下与真实 ID 值相同，但是改变有效 ID，可以使进程有其他用户或组的权限。
- 补充组 ID：标识进程所属的额外组，新进程从其父进程处继承，登录 shell 则从系统组文件中获取其不充组 ID。

## 特权进程

特权进程指的是有效用户 ID 为 0 的进程，通常内核施加的限制对此类进程无效。

## 能力

linux 将赋予超级用户的权限划分为一组相互独立的单元，称之为能力，每次特权操作都与特定的能力相关，仅当进程组具有特定的能力时，才可以执行相应的操作。

可以赋予进程部分能力，使得其既能执行某些特权操作，又能防止其执行其他的特权操作。

## init 进程 

系统引导时，内核创建一个 init 进程，init 进程是所有进程之父，执行文件为 `/sbin/init`。

- 系统中所有的进程不是  init 创建的，就是他的子孙创建的
- init 进程号为 1，并且总是以超级用户权限运行
- 只有系统关闭才能终止此进程，超级用户也无法杀死该进程

## 守护进程

特点：

- 长生不老：通常在系统引导时启动，系统关闭时才退出
- 后台运行：无控制终端供其读取和写入数据

## 环境列表

每个进程都有一份环境列表，即在进程的用户空间保存的一组环境变量。

- 每个元素都是由一个名称及其相关值组成
- `fork()` 创建新进程时，会继承父进程的环境副本
- `exec()` 替换当前正在运行的程序时，新程序要么继承老程序的环境，要么在 `exec()` 调用参数中指定的新环境
- 大部分 shell 中，可以使用 `export`  命令来创建新的环境变量

 ## 资源限制

系统调用 `setrlimit()` 可以为进程消耗的各类资源设置一个上限。

资源限制分为两种：

- 软限制：限制进程可以消耗的资源总量
- 硬限制：限制软限制可以调整的上限
- 非特权进程只能设置软限制，调整0到相应的硬限制之间的任意值，硬限制只能降低，不能升高
- `fork()` 进程会继承其父进程对资源限制的设置
- `ulimit` 命令可以调整 shell 的资源限制，shell 为执行命令所创建的子进程将会继承上述限制

# 内存映射

调用系统 函数 `mmap()`  的进程可以在其虚拟地址空间中创建一个新的内存映射：

- 文件映射，将文件的部分区域映射入进程的虚拟内存，映射一旦完成，对对文件映射内容的访问则转换为对相应内存区域字节的操作，映射页面会按需自动从文件中加载
- 无文件对应的匿名映射，其映射页面的内容将会被初始化为0

由某进程所映射的内存可以与其它进程的映射共享，方式有两种：

- 两个进程都针对某一文件的相同部分加以映射
- `fork()` 创建的子进程自父进程处继承映射

当两个或多个进程共享页面时，内容修改的可见性由创建映射的标志所决定：

- 传入共享标志，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动
- 传入私有标志，对映射内容的修改就会为其他进程不可见，并且这些修改也不会造成对文件的改动

内存映射的应用：

- 以可执行文件的相应段来初始化进程的文本段、内存分配
- 文件 IO
- 进程间通信

# 静态库和共享库



 目标库就是将一组函数加以编译，并置于一个文件中，供其他程序调用。

## 静态库

静态库称为档案文件(archives)，本质上是对已编译目标模块的一种结构化整合。

静态链接：主程序会对静态库中隶属于各个目标模块的不同函数加以引用，链接器在解析了引用情况后，会从库中抽取所需的目标模块的副本，将其复制到最终可执行文件中。

静态链接的缺点：

- 在不同的可执行文件中可能都有相同的目标代码副本，这是对磁盘空间的浪费
- 调用同一库函数的程序，如果都是静态链接，并且同时加载，每个程序的所用函数都有一份副本驻留在内存中，会造成内存的浪费
- 如果对库函数进行了修改，所有调用该函数的可执行程序都要重新链接新的静态库

## 共享库

设计共享库是为了解决静态库的问题。

程序链接共享库时，链接器就不会把库中的目标模块复制到可执行文件中，而是在可执行文件中写入一条记录，以表明可执行文件在运行时需要使用该共享库，一旦运行时将可执行文件载入内存中，动态链接器将会确保可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的相应函数关联起来。

共享库的有点：

- 经过编译处理的函数仅在共享库内保持一份，从而节约了磁盘空间
- 运行时，共享代码在内存中只需保持一份，且可供所有运行中的程序使用，从而节约了内存
- 共享库中的函数更新，只需要重新编译共享库，程序会在下一次执行时自动使用新的函数

# 进程间通信及同步

- 信号，用来表示事件的发生
- 管道和FIFO，用于在进程间传递数据
- 套接字，供同一台主机或者联网的不同主机上所运行的进程之间传递数据
- 文件锁定，为防止其他进程读取或者更新文件，允许进程对文件的部分区域加以锁定
- 消息队列，用于在进程之间交换消息
- 信号量，用来同步进程动作
- 共享内存，允许两个及两个以上的进程共享一块内存，当进程改变了共享内存的内容时，其他进程会立即了解此变化

# 信号

常将信号称为软件中断，进程收到信号，就意味着某一事件或者异常情况发生。

采用不同的整数来标识信号类型，以 `SIGxxxx`  形式定义。

内核和其他进程(具有相应的权限)或者进程自身都可以向进程发送信号。

内核向进程发送信号：

- 用户键入中断字符(ctrl+c)
- 进程的某一个子进程已经终止
- 进程设定的定时器已到期
- 进程尝试访问无效的内存地址

在 shell 中可以用 `kill` 命令向进程发送信号，程序内部，系统调用 `kill()` 可提供相同的功能。

收到信号后，进程通常采取的动作：

- 忽略信号
- 被信号杀死
- 先挂起，之后再被专用信号唤醒

信号从产生到送到进程期间，一直处于挂起，系统会在进程下一次获取调度时，将处于挂起的信号同时送达，如果进程正在运行，则会立即送达。

可以自定义信号处理器。

可以设置信号屏蔽集，处于屏蔽集的信号将一直保持挂起，直到该信号从屏蔽集中移除。

# 线程

每个进程都可以执行多个线程，可将线程想象为共享同一虚拟内存以及一干属性的进程。

- 每个线程都会执行相同的程序代码，共享同一数据区域和堆
- 每个线程都拥有自己的栈，用来装载本地变量和函数调用链接信息

线程之间可以通过共享全局变量进行通信，借助互斥机制和条件变量可以实现通信和同步。

# 进程组和 shell 任务控制

支持任务控制的 shell 中，会将管道内所有进程置于一个新的进程组或任务中：

- 进程组中的每个进程都具有相同的进程组标识符，其实就是进程组组长的进程 ID
- 内核可以对进程组中的所有程序执行各种动作，尤其是信号传递。

# 会话、控制终端和控制进程

会话是指一组进程组：

- 会话中的所有进程都具有相同的会话标识符，会话首进程是指创建会话的进程，其进程 ID 会成为会话 ID
- 使用会话最多的是支持任务控制的 shell，由 shell 所创建的所有进程组与 shell 自身隶属于同一会话，shell 是此会话的会话首进程

通常，会话都与某个控制终端相关：

- 一个终端至多只能成为一个会话的控制终端

- 打开控制终端会使首进程成为终端的控制进程，一旦关闭了与终端的连接，控制进程会收到一个 SIGHUP 信号

- 在任一时点，会话总有一个前台进程组，可以从终端中读取输入，向终端发送输出

- 一个会话可以拥有任意数量的后台进程组，由以 `&` 结尾的命令行创建

- 支持多任务的 shell 提供如下命令

  - 列出所有任务
  - 向任务发送信号
  - 前后台任务之间切换

# 伪终端

伪终端是一对相互链接的虚拟设备，也称为主从设备，在这对设备之间，有一条 IPC 信道，可供数据双向传递。

从设备所提供的接口其行为方式与终端类似，可以将为某个终端编写的程序在从设备运行，其行为与在传统终端执行是一致的。

# 日期和时间

进程涉及两种类型的时间：

- 真实时间，进程的生命期内以某个标准时间点为起点测量得出的时间
- 进程时间，也称为 CPU 时间，指的是进程自启动后，所占用的 CPU 总时间，包括：
  - 系统 CPU 时间，内核中执行代码花费的时间
  - 用户 CPU 时间，用户模式下执行代码花费的时间

`time` 命令可以显示出真实时间，系统 CPU 时间以及用户 CPU 时间。

# 客户端/服务器架构

客户端/服务器应用由两个组件进程组成：

- 客户端：向服务器发送请求消息，请求服务器执行某些特定的服务
- 服务器：分析客户端的请求，执行相应的动作，然后向客户端回发相应消息

# 实时性

实时性应用程序指的是那些需要对输入做出及时响应的程序。

# /proc 文件系统

/proc 文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口。

可以通过一组以 `/proc/PID` 形式命名的目录查看系统中运行的各种进程相关信息。



















































