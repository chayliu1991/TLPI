SETBUF(3)                                                                                                   Linux Programmer's Manual                                                                                                   SETBUF(3)

NNAAMMEE
       setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssttddiioo..hh>>

       vvooiidd sseettbbuuff((FFIILLEE **_s_t_r_e_a_m,, cchhaarr **_b_u_f));;

       vvooiidd sseettbbuuffffeerr((FFIILLEE **_s_t_r_e_a_m,, cchhaarr **_b_u_f,, ssiizzee__tt _s_i_z_e));;

       vvooiidd sseettlliinneebbuuff((FFIILLEE **_s_t_r_e_a_m));;

       iinntt sseettvvbbuuff((FFIILLEE **_s_t_r_e_a_m,, cchhaarr **_b_u_f,, iinntt _m_o_d_e,, ssiizzee__tt _s_i_z_e));;

   Feature Test Macro Requirements for glibc (see ffeeaattuurree__tteesstt__mmaaccrrooss(7)):

       sseettbbuuffffeerr(), sseettlliinneebbuuff(): _BSD_SOURCE

DDEESSCCRRIIPPTTIIOONN
       The three types of buffering available are unbuffered, block buffered, and line buffered.  When an output stream is unbuffered, information appears on the destination file or terminal as soon as written; when it is block buffered many
       characters are saved up and written as a block; when it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically _s_t_d_i_n).  The function  fffflluusshh(3)  may
       be used to force the block out early.  (See ffcclloossee(3).)

       Normally all files are block buffered.  If a stream refers to a terminal (as _s_t_d_o_u_t normally does), it is line buffered.  The standard error stream _s_t_d_e_r_r is always unbuffered by default.

       The sseettvvbbuuff() function may be used on any open stream to change its buffer.  The _m_o_d_e argument must be one of the following three macros:

              __IIOONNBBFF unbuffered

              __IIOOLLBBFF line buffered

              __IIOOFFBBFF fully buffered

       Except  for  unbuffered  files,  the _b_u_f argument should point to a buffer at least _s_i_z_e bytes long; this buffer will be used instead of the current buffer.  If the argument _b_u_f is NULL, only the mode is affected; a new buffer will be
       allocated on the next read or write operation.  The sseettvvbbuuff() function may be used only after opening a stream and before any other operations have been performed on it.

       The other three calls are, in effect, simply aliases for calls to sseettvvbbuuff().  The sseettbbuuff() function is exactly equivalent to the call

           setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);

       The sseettbbuuffffeerr() function is the same, except that the size of the buffer is up to the caller, rather than being determined by the default BBUUFFSSIIZZ.  The sseettlliinneebbuuff() function is exactly equivalent to the call:

           setvbuf(stream, NULL, _IOLBF, 0);

RREETTUURRNN VVAALLUUEE
       The function sseettvvbbuuff() returns 0 on success.  It returns nonzero on failure (_m_o_d_e is invalid or the request cannot be honored).  It may set _e_r_r_n_o on failure.

       The other functions do not return a value.

AATTTTRRIIBBUUTTEESS
       For an explanation of the terms used in this section, see aattttrriibbuutteess(7).

       ┌────────────────────────┬───────────────┬─────────┐
       │IInntteerrffaaccee               │ AAttttrriibbuuttee     │ VVaalluuee   │
       ├────────────────────────┼───────────────┼─────────┤
       │sseettbbuuff(), sseettbbuuffffeerr(),  │ Thread safety │ MT-Safe │
       │sseettlliinneebbuuff(), sseettvvbbuuff() │               │         │
       └────────────────────────┴───────────────┴─────────┘
CCOONNFFOORRMMIINNGG TTOO
       The sseettbbuuff() and sseettvvbbuuff() functions conform to C89 and C99.

BBUUGGSS
       You must make sure that the space that _b_u_f points to still exists by the time _s_t_r_e_a_m is closed, which also happens at program termination.  For example, the following is invalid:

       #include <stdio.h>

       int
       main(void)
       {
           char buf[BUFSIZ];
           setbuf(stdin, buf);
           printf("Hello, world!\n");
           return 0;
       }

SSEEEE AALLSSOO
       ffcclloossee(3), fffflluusshh(3), ffooppeenn(3), ffrreeaadd(3), mmaalllloocc(3), pprriinnttff(3), ppuuttss(3)

CCOOLLOOPPHHOONN
       This page is part of release 4.04 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about reporting bugs, and the latest version of this page, can be found at http://www.kernel.org/doc/man-pages/.

Linux                                                                                                               2015-05-07                                                                                                          SETBUF(3)
FFLUSH(3)                                                                                                   Linux Programmer's Manual                                                                                                   FFLUSH(3)

NNAAMMEE
       fflush - flush a stream

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ssttddiioo..hh>>

       iinntt fffflluusshh((FFIILLEE **_s_t_r_e_a_m));;

DDEESSCCRRIIPPTTIIOONN
       For output streams, fffflluusshh() forces a write of all user-space buffered data for the given output or update _s_t_r_e_a_m via the stream's underlying write function.

       For input streams associated with seekable files (e.g., disk files, but not pipes or terminals), fffflluusshh() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.

       The open status of the stream is unaffected.

       If the _s_t_r_e_a_m argument is NULL, fffflluusshh() flushes _a_l_l open output streams.

       For a nonlocking counterpart, see uunnlloocckkeedd__ssttddiioo(3).

RREETTUURRNN VVAALLUUEE
       Upon successful completion 0 is returned.  Otherwise, EEOOFF is returned and _e_r_r_n_o is set to indicate the error.

EERRRROORRSS
       EEBBAADDFF  _s_t_r_e_a_m is not an open stream, or is not open for writing.

       The function fffflluusshh() may also fail and set _e_r_r_n_o for any of the errors specified for wwrriittee(2).

AATTTTRRIIBBUUTTEESS
       For an explanation of the terms used in this section, see aattttrriibbuutteess(7).

       ┌──────────┬───────────────┬─────────┐
       │IInntteerrffaaccee │ AAttttrriibbuuttee     │ VVaalluuee   │
       ├──────────┼───────────────┼─────────┤
       │fffflluusshh()  │ Thread safety │ MT-Safe │
       └──────────┴───────────────┴─────────┘
CCOONNFFOORRMMIINNGG TTOO
       C89, C99, POSIX.1-2001, POSIX.1-2008.

       POSIX.1-2001 did not specify the behavior for flushing of input streams, but the behavior is specified in POSIX.1-2008.

NNOOTTEESS
       Note that fffflluusshh() flushes only the user-space buffers provided by the C library.  To ensure that the data is physically stored on disk the kernel buffers must be flushed too, for example, with ssyynncc(2) or ffssyynncc(2).

SSEEEE AALLSSOO
       ffssyynncc(2), ssyynncc(2), wwrriittee(2), ffcclloossee(3), ffooppeenn(3), sseettbbuuff(3), uunnlloocckkeedd__ssttddiioo(3)

CCOOLLOOPPHHOONN
       This page is part of release 4.04 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about reporting bugs, and the latest version of this page, can be found at http://www.kernel.org/doc/man-pages/.

GNU                                                                                                                 2015-03-02                                                                                                          FFLUSH(3)
